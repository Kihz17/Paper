From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kihz17 <mitchdawdy@gmail.com>
Date: Thu, 10 Oct 2024 04:59:28 -0700
Subject: [PATCH] Add Radiance API


diff --git a/src/main/java/com/destroystokyo/paper/events/AddPlayerPacketEvent.java b/src/main/java/com/destroystokyo/paper/events/AddPlayerPacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..7d3bbfe6b534b51bf43410b6cdf699fadd7abead
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/AddPlayerPacketEvent.java
@@ -0,0 +1,49 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class AddPlayerPacketEvent extends PlayerEvent implements Cancellable {
+    private ClientboundAddEntityPacket packet;
+    private boolean cancelled;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public AddPlayerPacketEvent(@NotNull Player who, ClientboundAddEntityPacket packet) {
+        super(who);
+        this.packet = packet;
+    }
+
+    public ClientboundAddEntityPacket getPacket() {
+        return packet;
+    }
+
+    public void setPacket(ClientboundAddEntityPacket packet) {
+        this.packet = packet;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
+
diff --git a/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..bfa8b4d835a6c9451edb58568dfd146120add4b4
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java
@@ -0,0 +1,75 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class BroadcastEntityMovePacketEvent extends EntityEvent {
+    private final Packet<?> packet;
+    private final PacketType packetType;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public BroadcastEntityMovePacketEvent(@NotNull Entity what, Packet<?> packet) {
+        super(what);
+        this.packet = packet;
+
+        if(packet instanceof ClientboundMoveEntityPacket.Pos) {
+            this.packetType = PacketType.POS;
+        } else if(packet instanceof ClientboundMoveEntityPacket.Rot) {
+            this.packetType = PacketType.ROT;
+        } else if(packet instanceof ClientboundMoveEntityPacket.PosRot) {
+            this.packetType = PacketType.POS_ROT;
+        } else if(packet instanceof ClientboundTeleportEntityPacket) {
+            this.packetType = PacketType.TELEPORT;
+        } else {
+            this.packetType = PacketType.NONE;
+        }
+    }
+
+    public Packet<?> getPacket() {
+        return packet;
+    }
+
+    public ClientboundMoveEntityPacket.Pos getAsPosPacket() {
+        return (ClientboundMoveEntityPacket.Pos) packet;
+    }
+
+    public ClientboundMoveEntityPacket.Rot getAsRotPacket() {
+        return (ClientboundMoveEntityPacket.Rot) packet;
+    }
+
+    public ClientboundMoveEntityPacket.PosRot getAsPosRotPacket() {
+        return (ClientboundMoveEntityPacket.PosRot) packet;
+    }
+
+    public ClientboundTeleportEntityPacket getAsTeleportPacket() {
+        return (ClientboundTeleportEntityPacket) packet;
+    }
+
+    public PacketType getPacketType() {
+        return packetType;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    public enum PacketType {
+        NONE,
+        POS,
+        ROT,
+        POS_ROT,
+        TELEPORT
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/PlayerPingEvent.java b/src/main/java/com/destroystokyo/paper/events/PlayerPingEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..98e047cebf73f5045dd612bd6bb77ee4728b6b31
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/PlayerPingEvent.java
@@ -0,0 +1,31 @@
+package com.destroystokyo.paper.events;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerPingEvent extends PlayerEvent {
+    private final int latency;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public PlayerPingEvent(@NotNull Player who, int latency) {
+        super(who);
+        this.latency = latency;
+    }
+
+    public int getLatency() {
+        return latency;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/PlayerPreTrackEntityEvent.java b/src/main/java/com/destroystokyo/paper/events/PlayerPreTrackEntityEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b772ea7d725f7acd2e9a5ce0d967bd8ee78ba36a
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/PlayerPreTrackEntityEvent.java
@@ -0,0 +1,43 @@
+package com.destroystokyo.paper.events;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerPreTrackEntityEvent extends PlayerEvent {
+    private final TrackType type;
+    private final Entity tracked;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public PlayerPreTrackEntityEvent(@NotNull Player who, @NotNull Entity tracked, TrackType type) {
+        super(who);
+        this.tracked = tracked;
+        this.type = type;
+    }
+
+    public Entity getTracked() {
+        return tracked;
+    }
+
+    public TrackType getTrackType() {
+        return type;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    public enum TrackType {
+        START,
+        STOP
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/PlayerTrackEntityEvent.java b/src/main/java/com/destroystokyo/paper/events/PlayerTrackEntityEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7d06229b90318f03d906e3bf867dff9a01166f5
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/PlayerTrackEntityEvent.java
@@ -0,0 +1,43 @@
+package com.destroystokyo.paper.events;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerTrackEntityEvent extends PlayerEvent {
+    private final TrackType type;
+    private final Entity tracked;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public PlayerTrackEntityEvent(@NotNull Player who, @NotNull Entity tracked, TrackType type) {
+        super(who);
+        this.tracked = tracked;
+        this.type = type;
+    }
+
+    public Entity getTracked() {
+        return tracked;
+    }
+
+    public TrackType getTrackType() {
+        return type;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    public enum TrackType {
+        START,
+        STOP
+    }
+}
+
diff --git a/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java b/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..e13ce2b1df52115c567cf505706d2c9e095590de
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java
@@ -0,0 +1,37 @@
+package com.destroystokyo.paper.events;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerUpdateEntityLineOfSightEvent extends PlayerEvent {
+    private final Entity entityInLOS;
+    private final boolean isInLOS;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public PlayerUpdateEntityLineOfSightEvent(@NotNull Player player, @NotNull Entity entity, boolean isInLOS) {
+        super(player);
+        this.entityInLOS = entity;
+        this.isInLOS = isInLOS;
+    }
+
+    public Entity getEntity() {
+        return entityInLOS;
+    }
+
+    public boolean isInLOS() {
+        return isInLOS;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/SendEntityDataPacketEvent.java b/src/main/java/com/destroystokyo/paper/events/SendEntityDataPacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c4076272431577dbde9269da8de8f0c16b0df84
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/SendEntityDataPacketEvent.java
@@ -0,0 +1,54 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
+import net.minecraft.network.syncher.SynchedEntityData;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class SendEntityDataPacketEvent extends PlayerEvent implements Cancellable {
+    private final List<SynchedEntityData.DataValue<?>> dataItems;
+    private final Entity entity;
+    private boolean cancelled;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public SendEntityDataPacketEvent(@NotNull Player who, Entity entity, List<SynchedEntityData.DataValue<?>> dataItems) {
+        super(who);
+        this.entity = entity;
+        this.dataItems = dataItems;
+    }
+
+    public List<SynchedEntityData.DataValue<?>> getDataItems() {
+        return dataItems;
+    }
+
+    public Entity getEntity() {
+        return entity;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPlayerTeamPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPlayerTeamPacket.java
index f8fe125f12a6a00899d1d6acfa448be882b81557..af56bc1d52a513f3a3786c52f1eed508690d6fb5 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPlayerTeamPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPlayerTeamPacket.java
@@ -18,19 +18,19 @@ public class ClientboundSetPlayerTeamPacket implements Packet<ClientGamePacketLi
     public static final StreamCodec<RegistryFriendlyByteBuf, ClientboundSetPlayerTeamPacket> STREAM_CODEC = Packet.codec(
         ClientboundSetPlayerTeamPacket::write, ClientboundSetPlayerTeamPacket::new
     );
-    private static final int METHOD_ADD = 0;
-    private static final int METHOD_REMOVE = 1;
-    private static final int METHOD_CHANGE = 2;
-    private static final int METHOD_JOIN = 3;
-    private static final int METHOD_LEAVE = 4;
-    private static final int MAX_VISIBILITY_LENGTH = 40;
-    private static final int MAX_COLLISION_LENGTH = 40;
+    public static final int METHOD_ADD = 0;
+    public static final int METHOD_REMOVE = 1;
+    public static final int METHOD_CHANGE = 2;
+    public static final int METHOD_JOIN = 3;
+    public static final int METHOD_LEAVE = 4;
+    public static final int MAX_VISIBILITY_LENGTH = 40;
+    public static final int MAX_COLLISION_LENGTH = 40;
     private final int method;
     private final String name;
     private final Collection<String> players;
     private final Optional<ClientboundSetPlayerTeamPacket.Parameters> parameters;
 
-    private ClientboundSetPlayerTeamPacket(
+    public ClientboundSetPlayerTeamPacket(
         String teamName, int packetType, Optional<ClientboundSetPlayerTeamPacket.Parameters> team, Collection<String> playerNames
     ) {
         this.name = teamName;
@@ -39,6 +39,7 @@ public class ClientboundSetPlayerTeamPacket implements Packet<ClientGamePacketLi
         this.players = ImmutableList.copyOf(playerNames);
     }
 
+
     public static ClientboundSetPlayerTeamPacket createAddOrModifyPacket(PlayerTeam team, boolean updatePlayers) {
         return new ClientboundSetPlayerTeamPacket(
             team.getName(),
@@ -163,6 +164,16 @@ public class ClientboundSetPlayerTeamPacket implements Packet<ClientGamePacketLi
             this.playerSuffix = team.getPlayerSuffix();
         }
 
+        public Parameters(Component displayName, Component playerPrefix, Component playerSuffix, String nametagVisibility, String collisionRule, ChatFormatting color, int options) {
+            this.displayName = displayName;
+            this.options = options;
+            this.nametagVisibility = nametagVisibility;
+            this.collisionRule = collisionRule;
+            this.color = color;
+            this.playerPrefix = playerPrefix;
+            this.playerSuffix = playerSuffix;
+        }
+
         public Parameters(RegistryFriendlyByteBuf buf) {
             this.displayName = ComponentSerialization.TRUSTED_STREAM_CODEC.decode(buf);
             this.options = buf.readByte();
diff --git a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
index 0f99733660f91280e4c6262cf75b3c9cae86f65a..cee9176428b5c73eecb3380c1004103d6045a24e 100644
--- a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
+++ b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
@@ -227,6 +227,10 @@ public class SynchedEntityData {
             }
         }
 
+        public DataValue<T> copy() {
+            return new DataValue<>(this.id, this.serializer, this.value);
+        }
+
         public static SynchedEntityData.DataValue<?> read(RegistryFriendlyByteBuf buf, int id) {
             int j = buf.readVarInt();
             EntityDataSerializer<?> datawatcherserializer = EntityDataSerializers.getSerializer(j);
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 8ea2f24695f5dad55e21f238b69442513e7a90c6..43d669fc0ffcc8272f5b8fd19fc2c7a05ab0617b 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -1,5 +1,10 @@
 package net.minecraft.server.level;
 
+import com.destroystokyo.paper.events.AddPlayerPacketEvent;
+import com.destroystokyo.paper.events.BroadcastEntityMovePacketEvent;
+import com.destroystokyo.paper.events.PlayerPreTrackEntityEvent;
+import com.destroystokyo.paper.events.PlayerTrackEntityEvent;
+import com.destroystokyo.paper.events.SendEntityDataPacketEvent;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
@@ -11,11 +16,13 @@ import java.util.List;
 import java.util.Objects;
 import java.util.Set;
 import java.util.function.Consumer;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
+import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundBundlePacket;
 import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundProjectilePowerPacket;
@@ -31,6 +38,7 @@ import net.minecraft.network.protocol.game.ClientboundUpdateAttributesPacket;
 import net.minecraft.network.protocol.game.VecDeltaCodec;
 import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.entity.Leashable;
 import net.minecraft.world.entity.LivingEntity;
@@ -40,8 +48,11 @@ import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.entity.projectile.AbstractHurtingProjectile;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.MapItem;
+import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.saveddata.maps.MapId;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 
@@ -70,7 +81,7 @@ public class ServerEntity {
     private int lastSentYHeadRot;
     private Vec3 lastSentMovement;
     private int tickCount;
-    private int teleportDelay;
+    public int teleportDelay;
     private List<Entity> lastPassengers = com.google.common.collect.ImmutableList.of(); // Paper - optimize passenger checks
     private boolean wasRiding;
     private boolean wasOnGround;
@@ -79,6 +90,10 @@ public class ServerEntity {
     // CraftBukkit start
     private final Set<ServerPlayerConnection> trackedPlayers;
 
+    public static int losCheckInterval = 20;
+    public static double losYThreshold = 15;
+    public static double losHorizontalThreshold = 20;
+
     public ServerEntity(ServerLevel worldserver, Entity entity, int i, boolean flag, Consumer<Packet<?>> consumer, Set<ServerPlayerConnection> trackedPlayers) {
         this.trackedPlayers = trackedPlayers;
         // CraftBukkit end
@@ -152,6 +167,19 @@ public class ServerEntity {
             }
         }
 
+        // Check if each tracked entity can view this server entity
+        if(this.tickCount % losCheckInterval == 0) {
+            for(ServerPlayerConnection playerConn : trackedPlayers) {
+                ServerPlayer player = playerConn.getPlayer();
+
+                if(hasLOS(player)) { // We have LOS
+                    player.addEntityInLOS(this.entity.getUUID());
+                } else { // Not in LOS
+                    player.removeEntityInLOS(this.entity.getUUID());
+                }
+            }
+        }
+
         if (this.forceStateResync || this.tickCount % this.updateInterval == 0 || this.entity.hasImpulse || this.entity.getEntityData().isDirty()) { // Paper - fix desync when a player is added to the tracker
             int i;
             int j;
@@ -234,6 +262,7 @@ public class ServerEntity {
 
                 if (packet1 != null) {
                     this.broadcast.accept(packet1);
+                    this.entity.level().getCraftServer().getPluginManager().callEvent(new BroadcastEntityMovePacketEvent(this.entity.getBukkitEntity(), packet1));
                 }
 
                 this.sendDirtyEntityData();
@@ -295,17 +324,31 @@ public class ServerEntity {
     }
 
     public void removePairing(ServerPlayer player) {
+        PlayerPreTrackEntityEvent preEvt = new PlayerPreTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity(), PlayerPreTrackEntityEvent.TrackType.STOP);
+        level.getCraftServer().getPluginManager().callEvent(preEvt);
+
         this.entity.stopSeenByPlayer(player);
+        player.removeEntityInLOS(this.entity.getUUID());
         player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
+
+        PlayerTrackEntityEvent evt = new PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity(), PlayerTrackEntityEvent.TrackType.STOP);
+        level.getCraftServer().getPluginManager().callEvent(evt);
     }
 
     public void addPairing(ServerPlayer player) {
         List<Packet<? super ClientGamePacketListener>> list = new ArrayList();
 
         Objects.requireNonNull(list);
+
+        PlayerPreTrackEntityEvent preEvt = new PlayerPreTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity(), PlayerPreTrackEntityEvent.TrackType.START);
+        level.getCraftServer().getPluginManager().callEvent(preEvt);
+
         this.sendPairingData(player, list::add);
         player.connection.send(new ClientboundBundlePacket(list));
         this.entity.startSeenByPlayer(player);
+
+        PlayerTrackEntityEvent evt = new PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity(), PlayerTrackEntityEvent.TrackType.START);
+        level.getCraftServer().getPluginManager().callEvent(evt);
     }
 
     public void sendPairingData(ServerPlayer player, Consumer<Packet<ClientGamePacketListener>> sender) {
@@ -318,9 +361,24 @@ public class ServerEntity {
 
         Packet<ClientGamePacketListener> packet = this.entity.getAddEntityPacket(this);
 
-        sender.accept(packet);
+        if(packet instanceof ClientboundAddEntityPacket addEntityPacket && addEntityPacket.getType() == EntityType.PLAYER) {
+            AddPlayerPacketEvent event = new AddPlayerPacketEvent(player.getBukkitEntity(), addEntityPacket);
+            level.getCraftServer().getPluginManager().callEvent(event);
+            if(!event.isCancelled())
+                sender.accept(packet);
+        } else {
+            sender.accept(packet);
+        }
+
         if (this.trackedDataValues != null) {
-            sender.accept(new ClientboundSetEntityDataPacket(this.entity.getId(), this.trackedDataValues));
+            List<SynchedEntityData.DataValue<?>> clonedList = this.trackedDataValues.stream()
+                .map(SynchedEntityData.DataValue::copy)
+                .collect(Collectors.toList());
+
+            SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(player.getBukkitEntity(), entity.getBukkitEntity(), clonedList);
+            level.getCraftServer().getPluginManager().callEvent(event);
+            if(!event.isCancelled())
+                sender.accept(new ClientboundSetEntityDataPacket(this.entity.getId(), clonedList));
         }
 
         boolean flag = this.trackDelta;
@@ -411,7 +469,25 @@ public class ServerEntity {
 
         if (list != null) {
             this.trackedDataValues = datawatcher.getNonDefaultValues();
-            this.broadcastAndSend(new ClientboundSetEntityDataPacket(this.entity.getId(), list));
+
+            for(ServerPlayerConnection connection : trackedPlayers) {
+                List<SynchedEntityData.DataValue<?>> clonedList = list.stream()
+                    .map(SynchedEntityData.DataValue::copy)
+                    .collect(Collectors.toList());
+
+                SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(connection.getPlayer().getBukkitEntity(), entity.getBukkitEntity(), clonedList);
+                level.getCraftServer().getPluginManager().callEvent(event);
+                if(!event.isCancelled())
+                    connection.send(new ClientboundSetEntityDataPacket(entity.getId(), clonedList));
+            }
+
+            // We are a player, send to ourselves
+            if(entity instanceof ServerPlayer player) {
+                SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(player.getBukkitEntity(), entity.getBukkitEntity(), list);
+                level.getCraftServer().getPluginManager().callEvent(event);
+                if(!event.isCancelled())
+                    player.connection.send(new ClientboundSetEntityDataPacket(entity.getId(), list));
+            }
         }
 
         if (this.entity instanceof LivingEntity) {
@@ -438,4 +514,37 @@ public class ServerEntity {
         }
 
     }
+
+    private boolean hasLOS(ServerPlayer player) {
+        // Get distance from the player to this entity
+        double x = player.getX() - this.entity.getX();
+        double y = player.getY() - this.entity.getY();
+        double z = player.getZ() - this.entity.getZ();
+        double yDistance = Math.sqrt(y * y);
+        double horizontalDistance = Math.sqrt((x * x) + (z * z));
+
+        if(yDistance <= losYThreshold && horizontalDistance <= losHorizontalThreshold) // We are close enough to them, just return true
+            return true;
+
+        Vec3 start = player.getEyePosition();
+        Vec3 end = this.entity.getEyePosition();
+
+        // Do dot product test
+        float yaw = player.getYHeadRot();
+        float pitch = player.getXRot();
+        double yDir = -Math.sin(Math.toRadians(pitch));
+        double xz = Math.cos(Math.toRadians(pitch));
+        double xDir = -xz * Math.sin(Math.toRadians(yaw));
+        double zDir = xz * Math.cos(Math.toRadians(yaw));
+
+        Vec3 playerDir = new Vec3(xDir, yDir, zDir).normalize();
+        Vec3 dirToEntity = end.subtract(start).normalize();
+        if(playerDir.dot(dirToEntity) <= 0.2D) // Player is looking away from the entity, don't bother doing ray casting checks
+            return false;
+
+        ClipContext ray = new ClipContext(start, end, ClipContext.Block.OUTLINE, ClipContext.Fluid.NONE, player);
+        BlockHitResult hitResult = player.level().clipIgnoreTransparent(ray);
+
+        return hitResult.getType() != HitResult.Type.BLOCK;
+    }
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index c396580a9cfd86ff261bed439bb4662ae88010b5..a237d9e52fd4c78a4a9afc9fd724179f6c1aefdb 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1,5 +1,6 @@
 package net.minecraft.server.level;
 
+import com.destroystokyo.paper.events.PlayerUpdateEntityLineOfSightEvent;
 import com.google.common.net.InetAddresses;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
@@ -9,12 +10,14 @@ import com.mojang.serialization.Dynamic;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.Set;
+import java.util.UUID;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
@@ -303,6 +306,9 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
     public @Nullable String clientBrandName = null; // Paper - Brand support
     public org.bukkit.event.player.PlayerQuitEvent.QuitReason quitReason = null; // Paper - Add API for quit reason; there are a lot of changes to do if we change all methods leading to the event
 
+    public final Set<UUID> visibleEntities = new HashSet<>();
+    public final Set<UUID> ignoreLoSChecks = new HashSet<>();
+
     // Paper start - rewrite chunk system
     private ca.spottedleaf.moonrise.patches.chunk_system.player.RegionizedPlayerChunkLoader.PlayerChunkLoaderData chunkLoader;
     private final ca.spottedleaf.moonrise.patches.chunk_system.player.RegionizedPlayerChunkLoader.ViewDistanceHolder viewDistanceHolder = new ca.spottedleaf.moonrise.patches.chunk_system.player.RegionizedPlayerChunkLoader.ViewDistanceHolder();
@@ -2946,4 +2952,22 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
         return (CraftPlayer) super.getBukkitEntity();
     }
     // CraftBukkit end
+
+    public void addEntityInLOS(UUID uuid) {
+        if(!visibleEntities.contains(uuid)) {
+            org.bukkit.entity.Entity craftEntity = this.level().getCraftServer().getEntity(uuid);
+            if(craftEntity != null) {
+                visibleEntities.add(uuid);
+                this.level().getCraftServer().getPluginManager().callEvent(new PlayerUpdateEntityLineOfSightEvent(getBukkitEntity(), craftEntity, true));
+            }
+        }
+    }
+
+    public void removeEntityInLOS(UUID uuid) {
+        if(visibleEntities.remove(uuid)) {
+            org.bukkit.entity.Entity craftEntity = this.level().getCraftServer().getEntity(uuid);
+            if(craftEntity != null)
+                this.level().getCraftServer().getPluginManager().callEvent(new PlayerUpdateEntityLineOfSightEvent(getBukkitEntity(), craftEntity, false));
+        }
+    }
 }
diff --git a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index 6998f32f8d79dbdb6b31ffaa126602fc4a428616..16dd86540e142c63b54bac264ce973dd55753df9 100644
--- a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -1,5 +1,6 @@
 package net.minecraft.server.network;
 
+import com.destroystokyo.paper.events.PlayerPingEvent;
 import com.mojang.authlib.GameProfile;
 import com.mojang.logging.LogUtils;
 import java.util.Objects;
@@ -135,6 +136,9 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
 
             this.latency = (this.latency * 3 + i) / 4;
             this.keepAlivePending = false;
+
+            // Call latency event
+            this.player.level().getCraftServer().getPluginManager().callEvent(new PlayerPingEvent(this.player.getBukkitEntity(), latency));
         } else if (!this.isSingleplayerOwner()) {
             // Paper start - This needs to be handled on the main thread for plugins
             server.submit(() -> {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 4b54d0ea31062972e68ee8fafe3cfaf68f65a5cd..df2ada7e0358b1d95f601e347b845912c3e5d6e2 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.entity;
 
+import com.destroystokyo.paper.events.SendEntityDataPacketEvent;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Lists;
@@ -362,13 +363,13 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public static final int FLAG_INVISIBLE = 5;
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
-    private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
-    private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    protected static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
-    private static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
+    public static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
+    public static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private EntityInLevelCallback levelCallback;
     private final VecDeltaCodec packetPositionCodec;
     public boolean noCulling;
@@ -687,7 +688,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         List<SynchedEntityData.DataValue<?>> list = this.entityData.packAll(); // Paper - Update EVERYTHING not just not default
 
         if (list != null && to.getBukkitEntity().canSee(this.getBukkitEntity())) { // Paper
-            to.connection.send(new ClientboundSetEntityDataPacket(this.getId(), list));
+            SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(to.getBukkitEntity(), this.getBukkitEntity(), list);
+            level.getCraftServer().getPluginManager().callEvent(event);
+            if(!event.isCancelled())
+                to.connection.send(new ClientboundSetEntityDataPacket(this.getId(), list));
         }
     }
     // CraftBukkit end
@@ -720,7 +724,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             values.add(synchedValue.value());
         }
 
-        to.connection.send(new ClientboundSetEntityDataPacket(this.id, values));
+        SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(to.getBukkitEntity(), this.getBukkitEntity(), values);
+        level.getCraftServer().getPluginManager().callEvent(event);
+        if(!event.isCancelled())
+            to.connection.send(new ClientboundSetEntityDataPacket(this.id, values));
     }
     // Paper end
 
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 2aa6374cd4a96efd85899be8cd3172a8257bfe6b..11740a1cfcfdd16b89fed0775517debfc91f01d6 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -185,13 +185,13 @@ public abstract class LivingEntity extends Entity implements Attackable {
     protected static final int LIVING_ENTITY_FLAG_IS_USING = 1;
     protected static final int LIVING_ENTITY_FLAG_OFF_HAND = 2;
     public static final int LIVING_ENTITY_FLAG_SPIN_ATTACK = 4;
-    protected static final EntityDataAccessor<Byte> DATA_LIVING_ENTITY_FLAGS = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> DATA_LIVING_ENTITY_FLAGS = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BYTE);
     public static final EntityDataAccessor<Float> DATA_HEALTH_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.FLOAT);
-    private static final EntityDataAccessor<List<ParticleOptions>> DATA_EFFECT_PARTICLES = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.PARTICLES);
-    private static final EntityDataAccessor<Boolean> DATA_EFFECT_AMBIENCE_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<List<ParticleOptions>> DATA_EFFECT_PARTICLES = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.PARTICLES);
+    public static final EntityDataAccessor<Boolean> DATA_EFFECT_AMBIENCE_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BOOLEAN);
     public static final EntityDataAccessor<Integer> DATA_ARROW_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Integer> DATA_STINGER_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Optional<BlockPos>> SLEEPING_POS_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.OPTIONAL_BLOCK_POS);
+    public static final EntityDataAccessor<Integer> DATA_STINGER_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Optional<BlockPos>> SLEEPING_POS_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.OPTIONAL_BLOCK_POS);
     private static final int PARTICLE_FREQUENCY_WHEN_INVISIBLE = 15;
     protected static final EntityDimensions SLEEPING_DIMENSIONS = EntityDimensions.fixed(0.2F, 0.2F).withEyeHeight(0.2F);
     public static final float EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT = 0.5F;
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 09bcbc0ae36e4e69fee87a7e0c49acf496117a39..cc61b8e1706fe3c83de5378a0cfb45f744a12ba0 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -150,12 +150,12 @@ public abstract class Player extends LivingEntity {
     public static final EntityDimensions STANDING_DIMENSIONS = EntityDimensions.scalable(0.6F, 1.8F).withEyeHeight(1.62F).withAttachments(EntityAttachments.builder().attach(EntityAttachment.VEHICLE, Player.DEFAULT_VEHICLE_ATTACHMENT));
     // CraftBukkit - decompile error
     private static final Map<Pose, EntityDimensions> POSES = ImmutableMap.<Pose, EntityDimensions>builder().put(Pose.STANDING, Player.STANDING_DIMENSIONS).put(Pose.SLEEPING, Player.SLEEPING_DIMENSIONS).put(Pose.FALL_FLYING, EntityDimensions.scalable(0.6F, 0.6F).withEyeHeight(0.4F)).put(Pose.SWIMMING, EntityDimensions.scalable(0.6F, 0.6F).withEyeHeight(0.4F)).put(Pose.SPIN_ATTACK, EntityDimensions.scalable(0.6F, 0.6F).withEyeHeight(0.4F)).put(Pose.CROUCHING, EntityDimensions.scalable(0.6F, 1.5F).withEyeHeight(1.27F).withAttachments(EntityAttachments.builder().attach(EntityAttachment.VEHICLE, Player.DEFAULT_VEHICLE_ATTACHMENT))).put(Pose.DYING, EntityDimensions.fixed(0.2F, 0.2F).withEyeHeight(1.62F)).build();
-    private static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
-    private static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
+    public static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
     public static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
-    protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
+    public static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
+    public static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     private long timeEntitySatOnShoulder;
     final Inventory inventory = new Inventory(this);
     protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer(this); // CraftBukkit - add "this" to constructor
diff --git a/src/main/java/net/minecraft/world/level/BlockGetter.java b/src/main/java/net/minecraft/world/level/BlockGetter.java
index 0fa131a6c98adb498fc8d534e0e39647e80c6923..c690295d36818d121e688c17d0aa7f8bdfd6d227 100644
--- a/src/main/java/net/minecraft/world/level/BlockGetter.java
+++ b/src/main/java/net/minecraft/world/level/BlockGetter.java
@@ -128,6 +128,17 @@ public interface BlockGetter extends LevelHeightAccessor {
         });
     }
 
+    default BlockHitResult clipIgnoreTransparent(ClipContext context) {
+        return (BlockHitResult) traverseBlocksIgnoreTransparent(context.getFrom(), context.getTo(), context, (raytrace1, blockposition) -> {
+            return this.clip(raytrace1, blockposition); // CraftBukkit - moved into separate method
+        }, (raytrace1) -> {
+            Vec3 vec3d = raytrace1.getFrom().subtract(raytrace1.getTo());
+
+            Vec3 rayTraceHitPos = raytrace1.getTo();
+            return BlockHitResult.miss(raytrace1.getTo(), Direction.getNearest(vec3d.x, vec3d.y, vec3d.z), new BlockPos((int)rayTraceHitPos.x(), (int)rayTraceHitPos.y(), (int)rayTraceHitPos.z()));
+        });
+    }
+
     @Nullable
     default BlockHitResult clipWithInteractionOverride(Vec3 start, Vec3 end, BlockPos pos, VoxelShape shape, BlockState state) {
         BlockHitResult movingobjectpositionblock = shape.clip(start, end, pos);
@@ -223,4 +234,71 @@ public interface BlockGetter extends LevelHeightAccessor {
             }
         }
     }
+
+    private <T, C> T traverseBlocksIgnoreTransparent(Vec3 start, Vec3 end, C context, BiFunction<C, BlockPos, T> blockHitFactory, Function<C, T> missFactory) {
+        if (start.equals(end)) {
+            return missFactory.apply(context);
+        } else {
+            double d0 = Mth.lerp(-1.0E-7D, end.x, start.x);
+            double d1 = Mth.lerp(-1.0E-7D, end.y, start.y);
+            double d2 = Mth.lerp(-1.0E-7D, end.z, start.z);
+            double d3 = Mth.lerp(-1.0E-7D, start.x, end.x);
+            double d4 = Mth.lerp(-1.0E-7D, start.y, end.y);
+            double d5 = Mth.lerp(-1.0E-7D, start.z, end.z);
+            int i = Mth.floor(d3);
+            int j = Mth.floor(d4);
+            int k = Mth.floor(d5);
+
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(i, j, k);
+            boolean isTransparent = this.getBlockState(blockposition_mutableblockposition.immutable()).useShapeForLightOcclusion();
+            T t0 = isTransparent ? null : blockHitFactory.apply(context, blockposition_mutableblockposition);
+
+            if (t0 != null) {
+                return t0;
+            } else {
+                double d6 = d0 - d3;
+                double d7 = d1 - d4;
+                double d8 = d2 - d5;
+                int l = Mth.sign(d6);
+                int i1 = Mth.sign(d7);
+                int j1 = Mth.sign(d8);
+                double d9 = l == 0 ? Double.MAX_VALUE : (double) l / d6;
+                double d10 = i1 == 0 ? Double.MAX_VALUE : (double) i1 / d7;
+                double d11 = j1 == 0 ? Double.MAX_VALUE : (double) j1 / d8;
+                double d12 = d9 * (l > 0 ? 1.0D - Mth.frac(d3) : Mth.frac(d3));
+                double d13 = d10 * (i1 > 0 ? 1.0D - Mth.frac(d4) : Mth.frac(d4));
+                double d14 = d11 * (j1 > 0 ? 1.0D - Mth.frac(d5) : Mth.frac(d5));
+
+                T object; // CraftBukkit - decompile error
+
+                do {
+                    if (d12 > 1.0D && d13 > 1.0D && d14 > 1.0D) {
+                        return missFactory.apply(context);
+                    }
+
+                    if (d12 < d13) {
+                        if (d12 < d14) {
+                            i += l;
+                            d12 += d9;
+                        } else {
+                            k += j1;
+                            d14 += d11;
+                        }
+                    } else if (d13 < d14) {
+                        j += i1;
+                        d13 += d10;
+                    } else {
+                        k += j1;
+                        d14 += d11;
+                    }
+
+                    BlockPos.MutableBlockPos mutableBlockPos = blockposition_mutableblockposition.set(i, j, k);
+                    isTransparent = this.getBlockState(mutableBlockPos.immutable()).useShapeForLightOcclusion();
+                    object = isTransparent ? null : blockHitFactory.apply(context, mutableBlockPos);
+                } while (object == null);
+
+                return object;
+            }
+        }
+    }
 }
