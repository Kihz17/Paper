From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kihz17 <mitchdawdy@gmail.com>
Date: Sat, 18 Jun 2022 14:41:22 -0400
Subject: [PATCH] Resolve conflicts with 1.19 patches.


diff --git a/src/main/java/com/destroystokyo/paper/events/AddPlayerPacketEvent.java b/src/main/java/com/destroystokyo/paper/events/AddPlayerPacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..95de05174134dfccda6404f71b54d5f0eaba4649
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/AddPlayerPacketEvent.java
@@ -0,0 +1,48 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.network.protocol.game.ClientboundAddPlayerPacket;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class AddPlayerPacketEvent extends PlayerEvent implements Cancellable {
+    private ClientboundAddPlayerPacket packet;
+    private boolean cancelled;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public AddPlayerPacketEvent(@NotNull Player who, ClientboundAddPlayerPacket packet) {
+        super(who);
+        this.packet = packet;
+    }
+
+    public ClientboundAddPlayerPacket getPacket() {
+        return packet;
+    }
+
+    public void setPacket(ClientboundAddPlayerPacket packet) {
+        this.packet = packet;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..bfa8b4d835a6c9451edb58568dfd146120add4b4
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java
@@ -0,0 +1,75 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class BroadcastEntityMovePacketEvent extends EntityEvent {
+    private final Packet<?> packet;
+    private final PacketType packetType;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public BroadcastEntityMovePacketEvent(@NotNull Entity what, Packet<?> packet) {
+        super(what);
+        this.packet = packet;
+
+        if(packet instanceof ClientboundMoveEntityPacket.Pos) {
+            this.packetType = PacketType.POS;
+        } else if(packet instanceof ClientboundMoveEntityPacket.Rot) {
+            this.packetType = PacketType.ROT;
+        } else if(packet instanceof ClientboundMoveEntityPacket.PosRot) {
+            this.packetType = PacketType.POS_ROT;
+        } else if(packet instanceof ClientboundTeleportEntityPacket) {
+            this.packetType = PacketType.TELEPORT;
+        } else {
+            this.packetType = PacketType.NONE;
+        }
+    }
+
+    public Packet<?> getPacket() {
+        return packet;
+    }
+
+    public ClientboundMoveEntityPacket.Pos getAsPosPacket() {
+        return (ClientboundMoveEntityPacket.Pos) packet;
+    }
+
+    public ClientboundMoveEntityPacket.Rot getAsRotPacket() {
+        return (ClientboundMoveEntityPacket.Rot) packet;
+    }
+
+    public ClientboundMoveEntityPacket.PosRot getAsPosRotPacket() {
+        return (ClientboundMoveEntityPacket.PosRot) packet;
+    }
+
+    public ClientboundTeleportEntityPacket getAsTeleportPacket() {
+        return (ClientboundTeleportEntityPacket) packet;
+    }
+
+    public PacketType getPacketType() {
+        return packetType;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    public enum PacketType {
+        NONE,
+        POS,
+        ROT,
+        POS_ROT,
+        TELEPORT
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/BroadcastEntityVelocityPacketEvent.java b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityVelocityPacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..80271abd3902663cd63b2cfc0a72bb89dc2490d6
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityVelocityPacketEvent.java
@@ -0,0 +1,32 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class BroadcastEntityVelocityPacketEvent extends EntityEvent {
+    private Vec3 velocity;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public BroadcastEntityVelocityPacketEvent(@NotNull Entity what, Vec3 vel) {
+        super(what);
+        this.velocity = vel;
+    }
+
+    public Vec3 getVelocity() {
+        return velocity;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/PlayerTrackEntityEvent.java b/src/main/java/com/destroystokyo/paper/events/PlayerTrackEntityEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..080d437667d521a5a7e71276a6bf8e971093d92b
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/PlayerTrackEntityEvent.java
@@ -0,0 +1,43 @@
+package com.destroystokyo.paper.events;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerTrackEntityEvent extends PlayerEvent {
+    private final TrackType type;
+    private final Entity tracked;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public PlayerTrackEntityEvent(@NotNull Player who, @NotNull Entity tracked, TrackType type) {
+        super(who);
+        this.tracked = tracked;
+        this.type = type;
+    }
+
+    public Entity getTracked() {
+        return tracked;
+    }
+
+    public TrackType getTrackType() {
+        return type;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    public enum TrackType {
+        START,
+        STOP
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java b/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..0cf609ce93d2db618b9f2e693c1b5f8d9d657357
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java
@@ -0,0 +1,38 @@
+package com.destroystokyo.paper.events;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerUpdateEntityLineOfSightEvent extends PlayerEvent {
+    private final Entity entityInLOS;
+    private final boolean isInLOS;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public PlayerUpdateEntityLineOfSightEvent(@NotNull Player player, @NotNull Entity entity, boolean isInLOS) {
+        super(player);
+        this.entityInLOS = entity;
+        this.isInLOS = isInLOS;
+    }
+
+    public Entity getEntity() {
+        return entityInLOS;
+    }
+
+    public boolean isInLOS() {
+        return isInLOS;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/SendEntityDataPacketEvent.java b/src/main/java/com/destroystokyo/paper/events/SendEntityDataPacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..83d8296e5bb22b2278a85d1ddf55a3cdc0eb3aa7
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/SendEntityDataPacketEvent.java
@@ -0,0 +1,54 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
+import net.minecraft.network.syncher.SynchedEntityData;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class SendEntityDataPacketEvent extends PlayerEvent implements Cancellable {
+    private final List<SynchedEntityData.DataItem<?>> dataItems;
+    private final Entity entity;
+    private boolean cancelled;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public SendEntityDataPacketEvent(@NotNull Player who, ClientboundSetEntityDataPacket packet, Entity entity) {
+        super(who);
+        this.entity = entity;
+        this.dataItems = packet.getUnpackedData();
+    }
+
+    public List<SynchedEntityData.DataItem<?>> getDataItems() {
+        return dataItems;
+    }
+
+    public Entity getEntity() {
+        return entity;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index b65a3626d2e0817cd1e223ec3b10e82fa0339663..00ebdd4cde6945d79151acde279c4dd9f76811da 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -54,8 +54,8 @@ import org.slf4j.MarkerFactory;
 import io.netty.util.concurrent.AbstractEventExecutor; // Paper
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
-    private static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
-    private static final Logger LOGGER = LogUtils.getLogger();
+    public static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
+    public static final Logger LOGGER = LogUtils.getLogger();
     public static final Marker ROOT_MARKER = MarkerFactory.getMarker("NETWORK");
     public static final Marker PACKET_MARKER = (Marker) Util.make(MarkerFactory.getMarker("NETWORK_PACKETS"), (marker) -> {
         marker.add(Connection.ROOT_MARKER);
@@ -76,8 +76,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     public static final LazyLoadedValue<DefaultEventLoopGroup> LOCAL_WORKER_GROUP = new LazyLoadedValue<>(() -> {
         return new DefaultEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Client IO #%d").setDaemon(true).setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(LOGGER)).build()); // Paper
     });
-    private final PacketFlow receiving;
-    private final Queue<Connection.PacketHolder> queue = Queues.newConcurrentLinkedQueue();
+    public final PacketFlow receiving;
+    public final Queue<Connection.PacketHolder> queue = Queues.newConcurrentLinkedQueue();
     public Channel channel;
     public SocketAddress address;
     // Spigot Start
@@ -85,27 +85,27 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     public com.mojang.authlib.properties.Property[] spoofedProfile;
     public boolean preparing = true;
     // Spigot End
-    private PacketListener packetListener;
-    private Component disconnectedReason;
-    private boolean encrypted;
-    private boolean disconnectionHandled;
-    private int receivedPackets;
-    private int sentPackets;
-    private float averageReceivedPackets;
-    private float averageSentPackets;
-    private int tickCount;
-    private boolean handlingFault;
+    public PacketListener packetListener;
+    public Component disconnectedReason;
+    public boolean encrypted;
+    public boolean disconnectionHandled;
+    public int receivedPackets;
+    public int sentPackets;
+    public float averageReceivedPackets;
+    public float averageSentPackets;
+    public int tickCount;
+    public boolean handlingFault;
     // Paper start - NetworkClient implementation
     public int protocolVersion;
     public java.net.InetSocketAddress virtualHost;
-    private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
+    public static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
     // Optimize network
     public boolean isPending = true;
     public boolean queueImmunity = false;
     public ConnectionProtocol protocol;
     // Paper end
     // Paper start - add pending task queue
-    private final Queue<Runnable> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    public final Queue<Runnable> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
     public void execute(final Runnable run) {
         if (this.channel == null || !this.channel.isRegistered()) {
             run.run();
@@ -129,9 +129,9 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     // Paper start - allow controlled flushing
     volatile boolean canFlush = true;
-    private final java.util.concurrent.atomic.AtomicInteger packetWrites = new java.util.concurrent.atomic.AtomicInteger();
-    private int flushPacketsStart;
-    private final Object flushLock = new Object();
+    public final java.util.concurrent.atomic.AtomicInteger packetWrites = new java.util.concurrent.atomic.AtomicInteger();
+    public int flushPacketsStart;
+    public final Object flushLock = new Object();
 
     public void disableAutomaticFlush() {
         synchronized (this.flushLock) {
@@ -149,7 +149,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
     }
 
-    private final void flush() {
+    public final void flush() {
         if (this.channel.eventLoop().inEventLoop()) {
             this.channel.flush();
         } else {
@@ -166,8 +166,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     ) : null;
     protected final java.util.Map<Class<? extends net.minecraft.network.protocol.Packet<?>>, io.papermc.paper.util.IntervalledCounter> packetSpecificLimits = new java.util.HashMap<>();
 
-    private boolean stopReadingPackets;
-    private void killForPacketSpam() {
+    public boolean stopReadingPackets;
+    public void killForPacketSpam() {
         this.sendPacket(new ClientboundDisconnectPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla(io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.kickMessage)), (future) -> {
             this.disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.kickMessage));
         });
@@ -310,7 +310,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     }
 
-    private static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
+    public static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
         packet.handle((T) listener); // CraftBukkit - decompile error
     }
 
@@ -326,8 +326,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return null;
         }
     }
-    private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
-        private static java.util.List<Packet> buildExtraPackets(Packet packet) {
+    public static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
+        public static java.util.List<Packet> buildExtraPackets(Packet packet) {
             java.util.List<Packet> extra = packet.getExtraPackets();
             if (extra == null || extra.isEmpty()) {
                 return null;
@@ -337,7 +337,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return ret;
         }
 
-        private static void buildExtraPackets0(java.util.List<Packet> extraPackets, java.util.List<Packet> into) {
+        public static void buildExtraPackets0(java.util.List<Packet> extraPackets, java.util.List<Packet> into) {
             for (Packet extra : extraPackets) {
                 into.add(extra);
                 java.util.List<Packet> extraExtra = extra.getExtraPackets();
@@ -347,7 +347,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             }
         }
         // Paper start
-        private static boolean canSendImmediate(Connection networkManager, Packet<?> packet) {
+        public static boolean canSendImmediate(Connection networkManager, Packet<?> packet) {
             return networkManager.isPending || networkManager.protocol != ConnectionProtocol.PLAY ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundKeepAlivePacket ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerChatPacket ||
@@ -403,11 +403,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         // Paper end
     }
 
-    private void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
+    public void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
         // Paper start - add flush parameter
         this.writePacket(packet, callback, Boolean.TRUE);
     }
-    private void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, Boolean flushConditional) {
+    public void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, Boolean flushConditional) {
         this.packetWrites.getAndIncrement(); // must be befeore using canFlush
         boolean effectiveFlush = flushConditional == null ? this.canFlush : flushConditional.booleanValue();
         final boolean flush = effectiveFlush || packet instanceof net.minecraft.network.protocol.game.ClientboundKeepAlivePacket || packet instanceof ClientboundDisconnectPacket; // no delay for certain packets
@@ -441,11 +441,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     }
 
-    private void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState) {
+    public void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState) {
         // Paper start - add flush parameter
         this.doSendPacket(packet, callback, packetState, currentState, true);
     }
-    private void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState, boolean flush) {
+    public void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState, boolean flush) {
         // Paper end - add flush parameter
         if (packetState != currentState) {
             this.setProtocol(packetState);
@@ -481,12 +481,12 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         // Paper end
     }
 
-    private ConnectionProtocol getCurrentProtocol() {
+    public ConnectionProtocol getCurrentProtocol() {
         return (ConnectionProtocol) this.channel.attr(Connection.ATTRIBUTE_PROTOCOL).get();
     }
 
     // Paper start - rewrite this to be safer if ran off main thread
-    private boolean flushQueue() { // void -> boolean
+    public boolean flushQueue() { // void -> boolean
         if (!isConnected()) {
             return true;
         }
@@ -500,7 +500,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
         return false;
     }
-    private boolean processQueue() {
+    public boolean processQueue() {
         try { // Paper - add pending task queue
         if (this.queue.isEmpty()) return true;
         // Paper start - make only one flush call per sendPacketQueue() call
@@ -542,9 +542,9 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
     // Paper end
 
-    private static final int MAX_PER_TICK = io.papermc.paper.configuration.GlobalConfiguration.get().misc.maxJoinsPerTick; // Paper
-    private static int joinAttemptsThisTick; // Paper
-    private static int currTick; // Paper
+    public static final int MAX_PER_TICK = io.papermc.paper.configuration.GlobalConfiguration.get().misc.maxJoinsPerTick; // Paper
+    public static int joinAttemptsThisTick; // Paper
+    public static int currTick; // Paper
     public void tick() {
         this.flushQueue();
         // Paper start
@@ -789,7 +789,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         return this.averageSentPackets;
     }
 
-    private static class PacketHolder {
+    public static class PacketHolder {
 
         final Packet<?> packet;
         @Nullable
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 3b144c820531122eb37d41be06c182b5f5dc0724..a22ce982e044077c02171c1b8de3636c07867a17 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -1,5 +1,6 @@
 package net.minecraft.server.level;
 
+import com.destroystokyo.paper.events.*;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
@@ -10,19 +11,10 @@ import java.util.List;
 import java.util.Objects;
 import java.util.Set;
 import java.util.function.Consumer;
+import java.util.stream.Collectors;
+
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
-import net.minecraft.network.protocol.game.ClientboundRotateHeadPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
-import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundUpdateAttributesPacket;
-import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
-import net.minecraft.network.protocol.game.VecDeltaCodec;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
@@ -34,7 +26,10 @@ import net.minecraft.world.entity.decoration.ItemFrame;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.MapItem;
+import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
@@ -67,6 +62,10 @@ public class ServerEntity {
     // CraftBukkit start
     final Set<ServerPlayerConnection> trackedPlayers; // Paper - private -> package
 
+    public static int losCheckInterval = 20;
+    public static double losYThreshold = 15;
+    public static double losHorizontalThreshold = 20;
+
     public ServerEntity(ServerLevel worldserver, Entity entity, int i, boolean flag, Consumer<Packet<?>> consumer, Set<ServerPlayerConnection> trackedPlayers) {
         this.trackedPlayers = trackedPlayers;
         // CraftBukkit end
@@ -124,6 +123,19 @@ public class ServerEntity {
             }
         }
 
+        // Check if each tracked entity can view this server entity
+        if(this.tickCount % losCheckInterval == 0) {
+            for(ServerPlayerConnection playerConn : trackedPlayers) {
+                ServerPlayer player = playerConn.getPlayer();
+
+                if(hasLOS(player)) { // We have LOS
+                    player.addEntityInLOS(this.entity.getUUID());
+                } else { // Not in LOS
+                    player.removeEntityInLOS(this.entity.getUUID());
+                }
+            }
+        }
+
         if (this.tickCount % this.updateInterval == 0 || this.entity.hasImpulse || this.entity.getEntityData().isDirty()) {
             int i;
             int j;
@@ -188,11 +200,13 @@ public class ServerEntity {
                     if (d0 > 1.0E-7D || d0 > 0.0D && vec3d1.lengthSqr() == 0.0D) {
                         this.ap = vec3d1;
                         this.broadcast.accept(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.ap));
+                        this.entity.level.getCraftServer().getPluginManager().callEvent(new BroadcastEntityVelocityPacketEvent(this.entity.getBukkitEntity(), this.ap));
                     }
                 }
 
                 if (packet1 != null) {
                     this.broadcast.accept(packet1);
+                    this.entity.level.getCraftServer().getPluginManager().callEvent(new BroadcastEntityMovePacketEvent(this.entity.getBukkitEntity(), packet1));
                 }
 
                 this.sendDirtyEntityData();
@@ -247,7 +261,11 @@ public class ServerEntity {
 
     public void removePairing(ServerPlayer player) {
         this.entity.stopSeenByPlayer(player);
+        player.removeEntityInLOS(this.entity.getUUID());
         player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
+
+        PlayerTrackEntityEvent evt = new PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity(), PlayerTrackEntityEvent.TrackType.STOP);
+        level.getCraftServer().getPluginManager().callEvent(evt);
     }
 
     public void addPairing(ServerPlayer player) {
@@ -256,6 +274,9 @@ public class ServerEntity {
         Objects.requireNonNull(player.connection);
         this.sendPairingData(playerconnection::send, player); // CraftBukkit - add player
         this.entity.startSeenByPlayer(player);
+
+        PlayerTrackEntityEvent evt = new PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity(), PlayerTrackEntityEvent.TrackType.START);
+        level.getCraftServer().getPluginManager().callEvent(evt);
     }
 
     public void sendPairingData(Consumer<Packet<?>> consumer, ServerPlayer entityplayer) { // CraftBukkit - add player
@@ -269,9 +290,22 @@ public class ServerEntity {
         Packet<?> packet = this.entity.getAddEntityPacket();
 
         this.yHeadRotp = Mth.floor(this.entity.getYHeadRot() * 256.0F / 360.0F);
-        consumer.accept(packet);
+
+        if(packet instanceof ClientboundAddPlayerPacket addPlayerPacket) {
+            AddPlayerPacketEvent event = new AddPlayerPacketEvent(entityplayer.getBukkitEntity(), addPlayerPacket);
+            level.getCraftServer().getPluginManager().callEvent(event);
+            if(!event.isCancelled())
+                entityplayer.connection.send(event.getPacket());
+        } else {
+            consumer.accept(packet);
+        }
+
         if (!this.entity.getEntityData().isEmpty()) {
-            consumer.accept(new ClientboundSetEntityDataPacket(this.entity.getId(), this.entity.getEntityData(), true));
+            ClientboundSetEntityDataPacket dataPacket = new ClientboundSetEntityDataPacket(this.entity.getId(), this.entity.getEntityData(), true);
+            SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(entityplayer.getBukkitEntity(), dataPacket, entity.getBukkitEntity());
+            level.getCraftServer().getPluginManager().callEvent(event);
+            if(!event.isCancelled())
+                entityplayer.connection.send(dataPacket);
         }
 
         boolean flag = this.trackDelta;
@@ -360,7 +394,32 @@ public class ServerEntity {
         SynchedEntityData datawatcher = this.entity.getEntityData();
 
         if (datawatcher.isDirty()) {
-            this.broadcastAndSend(new ClientboundSetEntityDataPacket(this.entity.getId(), datawatcher, false));
+            List<SynchedEntityData.DataItem<?>> dirtyItems = datawatcher.packDirty();
+
+            if(dirtyItems != null) {
+
+                // Send to tracked players
+                for (ServerPlayerConnection connection : trackedPlayers) {
+                    List<SynchedEntityData.DataItem<?>> clonedList = dirtyItems.stream()
+                        .map(SynchedEntityData.DataItem::copy)
+                        .collect(Collectors.toList());
+
+                    ClientboundSetEntityDataPacket clonedPacket = new ClientboundSetEntityDataPacket(entity.getId(), clonedList);
+                    SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(connection.getPlayer().getBukkitEntity(), clonedPacket, entity.getBukkitEntity());
+                    level.getCraftServer().getPluginManager().callEvent(event);
+                    if(!event.isCancelled())
+                        connection.send(clonedPacket);
+                }
+
+                // We are a player, send to ourselves
+                if(entity instanceof ServerPlayer player) {
+                    ClientboundSetEntityDataPacket clonedPacket = new ClientboundSetEntityDataPacket(entity.getId(), dirtyItems);
+                    SendEntityDataPacketEvent event = new SendEntityDataPacketEvent(player.getBukkitEntity(), clonedPacket, entity.getBukkitEntity());
+                    level.getCraftServer().getPluginManager().callEvent(event);
+                    if(!event.isCancelled())
+                        player.connection.send(clonedPacket);
+                }
+            }
         }
 
         if (this.entity instanceof LivingEntity) {
@@ -393,4 +452,37 @@ public class ServerEntity {
         }
 
     }
+
+    private boolean hasLOS(ServerPlayer player) {
+        // Get distance from the player to this entity
+        double x = player.getX() - this.entity.getX();
+        double y = player.getY() - this.entity.getY();
+        double z = player.getZ() - this.entity.getZ();
+        double yDistance = Math.sqrt(y * y);
+        double horizontalDistance = Math.sqrt((x * x) + (z * z));
+
+        if(yDistance <= losYThreshold && horizontalDistance <= losHorizontalThreshold) // We are close enough to them, just return true
+            return true;
+
+        Vec3 start = player.getEyePosition();
+        Vec3 end = this.entity.getEyePosition();
+
+        // Do dot product test
+        float yaw = player.getYHeadRot();
+        float pitch = player.getXRot();
+        double yDir = -Math.sin(Math.toRadians(pitch));
+        double xz = Math.cos(Math.toRadians(pitch));
+        double xDir = -xz * Math.sin(Math.toRadians(yaw));
+        double zDir = xz * Math.cos(Math.toRadians(yaw));
+
+        Vec3 playerDir = new Vec3(xDir, yDir, zDir).normalize();
+        Vec3 dirToEntity = end.subtract(start).normalize();
+        if(playerDir.dot(dirToEntity) <= 0.2D) // Player is looking away from the entity, don't bother doing ray casting checks
+            return false;
+
+        ClipContext ray = new ClipContext(start, end, ClipContext.Block.OUTLINE, ClipContext.Fluid.NONE, player);
+        BlockHitResult hitResult = player.level.clipIgnoreTransparent(ray);
+
+        return hitResult.getType() != HitResult.Type.BLOCK;
+    }
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 7e0b5c7b5b8b47da815c202b0cbb8aee1cdfdfde..5777fa5df17154baea705a5b7777f2380f98f7d8 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1,17 +1,14 @@
 package net.minecraft.server.level;
 
 import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
+import com.destroystokyo.paper.events.PlayerUpdateEntityLineOfSightEvent;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.OptionalInt;
+
+import java.util.*;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -265,6 +262,9 @@ public class ServerPlayer extends Player {
     public final com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleHashSet; // Paper
     public org.bukkit.event.player.PlayerQuitEvent.QuitReason quitReason = null; // Paper - there are a lot of changes to do if we change all methods leading to the event
 
+    public final Set<UUID> visibleEntities = new HashSet<>();
+    public final Set<UUID> ignoreLoSChecks = new HashSet<>();
+
     public ServerPlayer(MinecraftServer server, ServerLevel world, GameProfile profile, @Nullable ProfilePublicKey publicKey) {
         super(world, world.getSharedSpawnPos(), world.getSharedSpawnAngle(), profile, publicKey);
         this.chatVisibility = ChatVisiblity.FULL;
@@ -337,6 +337,25 @@ public class ServerPlayer extends Player {
         this.maxHealthCache = this.getMaxHealth();
         this.cachedSingleMobDistanceMap = new com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<>(this); // Paper
     }
+
+    public void addEntityInLOS(UUID uuid) {
+        if(!visibleEntities.contains(uuid)) {
+            org.bukkit.entity.Entity craftEntity = this.level.getCraftServer().getEntity(uuid);
+            if(craftEntity != null) {
+                visibleEntities.add(uuid);
+                this.level.getCraftServer().getPluginManager().callEvent(new PlayerUpdateEntityLineOfSightEvent(getBukkitEntity(), craftEntity, true));
+            }
+        }
+    }
+
+    public void removeEntityInLOS(UUID uuid) {
+        if(visibleEntities.remove(uuid)) {
+            org.bukkit.entity.Entity craftEntity = this.level.getCraftServer().getEntity(uuid);
+            if(craftEntity != null)
+                this.level.getCraftServer().getPluginManager().callEvent(new PlayerUpdateEntityLineOfSightEvent(getBukkitEntity(), craftEntity, false));
+        }
+    }
+
     // Paper start - Chunk priority
     public BlockPos getPointInFront(double inFront) {
         double rads = Math.toRadians(net.minecraft.server.MCUtil.normalizeYaw(this.yRot + 90)); // MC rotates yaw 90 for some odd reason
diff --git a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
index c2d7f0ca042882e1bf76f150e9c9be9044ef887c..ecee24e3b2fb7fe38c2eaec3f78d42cccd8d6c12 100644
--- a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
+++ b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
@@ -61,9 +61,9 @@ public class ServerConnectionListener {
     final MinecraftServer server;
     public volatile boolean running;
     private final List<ChannelFuture> channels = Collections.synchronizedList(Lists.newArrayList());
-    final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
+    public final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
     // Paper start - prevent blocking on adding a new network manager while the server is ticking
-    private final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    public final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
     private static final boolean disableFlushConsolidation = Boolean.getBoolean("Paper.disableFlushConsolidate"); // Paper
     private final void addPending() {
         Connection manager = null;
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 630a762b71861bfe21c47a11d4fe05e1a3b7d339..9d7eba3ef561596f76a8d5ccef9c3f3d492247d5 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -388,7 +388,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                 this.disconnect(Component.translatable("disconnect.timeout", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
             }
         } else {
-            if (elapsedTime >= 15000L) { // 15 seconds
+            if (elapsedTime >= 5000L) { // 5 seconds
                 this.keepAlivePending = true;
                 this.keepAliveTime = currentTime;
                 this.keepAliveChallenge = currentTime;
@@ -3328,7 +3328,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
             int i = (int) (Util.getMillis() - this.keepAliveTime);
 
-            this.player.latency = (this.player.latency * 3 + i) / 4;
+            this.player.latency = i;
             this.keepAlivePending = false;
         } else if (!this.isSingleplayerOwner()) {
             // Paper start - This needs to be handled on the main thread for plugins
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 20cdfdb3b9351f74e89bc45b3ab972384165659a..d6d76c1449adb88d448d75caecb096545b172407 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -128,34 +128,34 @@ public abstract class PlayerList {
     public static final File IPBANLIST_FILE = new File("banned-ips.json");
     public static final File OPLIST_FILE = new File("ops.json");
     public static final File WHITELIST_FILE = new File("whitelist.json");
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final int SEND_PLAYER_INFO_INTERVAL = 600;
-    private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
-    private final MinecraftServer server;
+    public static final Logger LOGGER = LogUtils.getLogger();
+    public static final int SEND_PLAYER_INFO_INTERVAL = 600;
+    public static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
+    public final MinecraftServer server;
     public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
-    private final UserBanList bans;
-    private final IpBanList ipBans;
-    private final ServerOpList ops;
-    private final UserWhiteList whitelist;
-    private final Map<UUID, ServerPlayer> pendingPlayers = Maps.newHashMap(); // Paper
+    public final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
+    public final UserBanList bans;
+    public final IpBanList ipBans;
+    public final ServerOpList ops;
+    public final UserWhiteList whitelist;
+    public final Map<UUID, ServerPlayer> pendingPlayers = Maps.newHashMap(); // Paper
     // CraftBukkit start
-    // private final Map<UUID, ServerStatisticManager> stats;
-    // private final Map<UUID, AdvancementDataPlayer> advancements;
+    // public final Map<UUID, ServerStatisticManager> stats;
+    // public final Map<UUID, AdvancementDataPlayer> advancements;
     // CraftBukkit end
     public final PlayerDataStorage playerIo;
-    private boolean doWhiteList;
-    private final RegistryAccess.Frozen registryHolder;
+    public boolean doWhiteList;
+    public final RegistryAccess.Frozen registryHolder;
     protected int maxPlayers; public final void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; } // Paper - remove final and add setter
-    private int viewDistance;
-    private int simulationDistance;
-    private boolean allowCheatsForAllPlayers;
-    private static final boolean ALLOW_LOGOUTIVATOR = false;
-    private int sendAllPlayerInfoIn;
+    public int viewDistance;
+    public int simulationDistance;
+    public boolean allowCheatsForAllPlayers;
+    public static final boolean ALLOW_LOGOUTIVATOR = false;
+    public int sendAllPlayerInfoIn;
 
     // CraftBukkit start
-    private CraftServer cserver;
-    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
+    public CraftServer cserver;
+    public final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
     public @Nullable String collideRuleTeamName; // Paper - Team name used for collideRule
 
     public PlayerList(MinecraftServer server, RegistryAccess.Frozen registryManager, PlayerDataStorage saveHandler, int maxPlayers) {
@@ -325,7 +325,7 @@ public abstract class PlayerList {
         });
     }
 
-    private void postChunkLoadJoin(ServerPlayer player, ServerLevel worldserver1, Connection networkmanager, ServerGamePacketListenerImpl playerconnection, CompoundTag nbttagcompound, String s1, String s) {
+    public void postChunkLoadJoin(ServerPlayer player, ServerLevel worldserver1, Connection networkmanager, ServerGamePacketListenerImpl playerconnection, CompoundTag nbttagcompound, String s1, String s) {
         pendingPlayers.remove(player.getUUID(), player);
         if (!networkmanager.isConnected()) {
             return;
@@ -433,7 +433,7 @@ public abstract class PlayerList {
         }
         // Paper end
     }
-    private void mountSavedVehicle(ServerPlayer player, ServerLevel worldserver1, CompoundTag nbttagcompound) {
+    public void mountSavedVehicle(ServerPlayer player, ServerLevel worldserver1, CompoundTag nbttagcompound) {
         // Paper end
         if (nbttagcompound != null && nbttagcompound.contains("RootVehicle", 10)) {
             CompoundTag nbttagcompound1 = nbttagcompound.getCompound("RootVehicle");
@@ -1154,7 +1154,7 @@ public abstract class PlayerList {
 
     }
 
-    private void sendPlayerPermissionLevel(ServerPlayer player, int permissionLevel) {
+    public void sendPlayerPermissionLevel(ServerPlayer player, int permissionLevel) {
         // Paper start - add recalculatePermissions parameter
         this.sendPlayerPermissionLevel(player, permissionLevel, true);
     }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index b0728b66c54dc22a5a98f150910d07f4b38ebd7e..dc2b816a0c211ed213619b16afb673699c51ad2f 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -331,21 +331,21 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public int invulnerableTime;
     protected boolean firstTick;
     protected final SynchedEntityData entityData;
-    protected static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
-    protected static final int FLAG_ONFIRE = 0;
-    private static final int FLAG_SHIFT_KEY_DOWN = 1;
-    private static final int FLAG_SPRINTING = 3;
-    private static final int FLAG_SWIMMING = 4;
-    private static final int FLAG_INVISIBLE = 5;
-    protected static final int FLAG_GLOWING = 6;
-    protected static final int FLAG_FALL_FLYING = 7;
-    private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
-    private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    protected static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
-    private static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
+    public static final int FLAG_ONFIRE = 0;
+    public static final int FLAG_SHIFT_KEY_DOWN = 1;
+    public static final int FLAG_SPRINTING = 3;
+    public static final int FLAG_SWIMMING = 4;
+    public static final int FLAG_INVISIBLE = 5;
+    public static final int FLAG_GLOWING = 6;
+    public static final int FLAG_FALL_FLYING = 7;
+    public static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
+    public static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
+    public static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private EntityInLevelCallback levelCallback;
     private final VecDeltaCodec packetPositionCodec;
     public boolean noCulling;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index e8dc99752d06ca40f17f3ad2c829b2447b703d7c..5ed39c1944d3ea813bfe2a3ad8895fc5369e7d36 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -157,27 +157,27 @@ public abstract class LivingEntity extends Entity {
     public static final int ARMOR_SLOT_OFFSET = 100;
     public static final int SWING_DURATION = 6;
     public static final int PLAYER_HURT_EXPERIENCE_TIME = 100;
-    private static final int DAMAGE_SOURCE_TIMEOUT = 40;
+    public static final int DAMAGE_SOURCE_TIMEOUT = 40;
     public static final double MIN_MOVEMENT_DISTANCE = 0.003D;
     public static final double DEFAULT_BASE_GRAVITY = 0.08D;
     public static final int DEATH_DURATION = 20;
-    private static final int WAIT_TICKS_BEFORE_ITEM_USE_EFFECTS = 7;
-    private static final int TICKS_PER_ELYTRA_FREE_FALL_EVENT = 10;
-    private static final int FREE_FALL_EVENTS_PER_ELYTRA_BREAK = 2;
+    public static final int WAIT_TICKS_BEFORE_ITEM_USE_EFFECTS = 7;
+    public static final int TICKS_PER_ELYTRA_FREE_FALL_EVENT = 10;
+    public static final int FREE_FALL_EVENTS_PER_ELYTRA_BREAK = 2;
     public static final int USE_ITEM_INTERVAL = 4;
-    private static final double MAX_LINE_OF_SIGHT_TEST_RANGE = 128.0D;
-    protected static final int LIVING_ENTITY_FLAG_IS_USING = 1;
-    protected static final int LIVING_ENTITY_FLAG_OFF_HAND = 2;
-    protected static final int LIVING_ENTITY_FLAG_SPIN_ATTACK = 4;
-    protected static final EntityDataAccessor<Byte> DATA_LIVING_ENTITY_FLAGS = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BYTE);
+    public static final double MAX_LINE_OF_SIGHT_TEST_RANGE = 128.0D;
+    public static final int LIVING_ENTITY_FLAG_IS_USING = 1;
+    public static final int LIVING_ENTITY_FLAG_OFF_HAND = 2;
+    public static final int LIVING_ENTITY_FLAG_SPIN_ATTACK = 4;
+    public static final EntityDataAccessor<Byte> DATA_LIVING_ENTITY_FLAGS = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BYTE);
     public static final EntityDataAccessor<Float> DATA_HEALTH_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.FLOAT);
-    private static final EntityDataAccessor<Integer> DATA_EFFECT_COLOR_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Boolean> DATA_EFFECT_AMBIENCE_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Integer> DATA_EFFECT_COLOR_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Boolean> DATA_EFFECT_AMBIENCE_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BOOLEAN);
     public static final EntityDataAccessor<Integer> DATA_ARROW_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Integer> DATA_STINGER_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Optional<BlockPos>> SLEEPING_POS_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.OPTIONAL_BLOCK_POS);
-    protected static final float DEFAULT_EYE_HEIGHT = 1.74F;
-    protected static final EntityDimensions SLEEPING_DIMENSIONS = EntityDimensions.fixed(0.2F, 0.2F);
+    public static final EntityDataAccessor<Integer> DATA_STINGER_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Optional<BlockPos>> SLEEPING_POS_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.OPTIONAL_BLOCK_POS);
+    public static final float DEFAULT_EYE_HEIGHT = 1.74F;
+    public static final EntityDimensions SLEEPING_DIMENSIONS = EntityDimensions.fixed(0.2F, 0.2F);
     public static final float EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT = 0.5F;
     private final AttributeMap attributes;
     public CombatTracker combatTracker = new CombatTracker(this);
diff --git a/src/main/java/net/minecraft/world/entity/monster/Phantom.java b/src/main/java/net/minecraft/world/entity/monster/Phantom.java
index cb81c5d37c72845133c4e59acaf8de56dcc9e62a..8c2bdf8199000f54929fbc377d35a00ec438a94c 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Phantom.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Phantom.java
@@ -45,7 +45,7 @@ public class Phantom extends FlyingMob implements Enemy {
 
     public static final float FLAP_DEGREES_PER_TICK = 7.448451F;
     public static final int TICKS_PER_FLAP = Mth.ceil(24.166098F);
-    private static final EntityDataAccessor<Integer> ID_SIZE = SynchedEntityData.defineId(Phantom.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Integer> ID_SIZE = SynchedEntityData.defineId(Phantom.class, EntityDataSerializers.INT);
     Vec3 moveTargetPoint;
     BlockPos anchorPoint;
     Phantom.AttackPhase attackPhase;
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index cd9cbfa5ef94994b3f7f2ecdde843620e7e6c071..1abcd926a91cba22ec617cf814205aa93a2d0aca 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -141,13 +141,13 @@ public abstract class Player extends LivingEntity {
     public static final EntityDimensions STANDING_DIMENSIONS = EntityDimensions.scalable(0.6F, 1.8F);
     // CraftBukkit - decompile error
     private static final Map<Pose, EntityDimensions> POSES = ImmutableMap.<Pose, EntityDimensions>builder().put(Pose.STANDING, Player.STANDING_DIMENSIONS).put(Pose.SLEEPING, Player.SLEEPING_DIMENSIONS).put(Pose.FALL_FLYING, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.SWIMMING, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.SPIN_ATTACK, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.CROUCHING, EntityDimensions.scalable(0.6F, 1.5F)).put(Pose.DYING, EntityDimensions.fixed(0.2F, 0.2F)).build();
-    private static final int FLY_ACHIEVEMENT_SPEED = 25;
-    private static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
-    private static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
+    public static final int FLY_ACHIEVEMENT_SPEED = 25;
+    public static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
+    public static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
     public static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
-    protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
+    public static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
+    public static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     private long timeEntitySatOnShoulder;
     private final Inventory inventory = new Inventory(this);
     protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer(this); // CraftBukkit - add "this" to constructor
@@ -1273,7 +1273,7 @@ public abstract class Player extends LivingEntity {
                     int i = b0 + EnchantmentHelper.getKnockbackBonus(this);
 
                     if (this.isSprinting() && flag) {
-                        sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_KNOCKBACK, this.getSoundSource(), 1.0F, 1.0F); // Paper - send while respecting visibility
+//                        sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_KNOCKBACK, this.getSoundSource(), 1.0F, 1.0F); // Paper - send while respecting visibility
                         ++i;
                         flag1 = true;
                     }
@@ -1353,7 +1353,7 @@ public abstract class Player extends LivingEntity {
                                 }
                             }
 
-                            sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_SWEEP, this.getSoundSource(), 1.0F, 1.0F); // Paper - send while respecting visibility
+//                            sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_SWEEP, this.getSoundSource(), 1.0F, 1.0F); // Paper - send while respecting visibility
                             this.sweepAttack();
                         }
 
@@ -1441,7 +1441,7 @@ public abstract class Player extends LivingEntity {
 
                         this.causeFoodExhaustion(level.spigotConfig.combatExhaustion, EntityExhaustionEvent.ExhaustionReason.ATTACK); // CraftBukkit - EntityExhaustionEvent // Spigot - Change to use configurable value
                     } else {
-                        sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_NODAMAGE, this.getSoundSource(), 1.0F, 1.0F); // Paper - send while respecting visibility
+//                        sendSoundEffect(this, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_NODAMAGE, this.getSoundSource(), 1.0F, 1.0F); // Paper - send while respecting visibility
                         if (flag4) {
                             target.clearFire();
                         }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
index bc01e5014e1355a225bdf5c47f2965290b45e2d2..0d9e6f2178f8c17c6a7deee4db8e6f27d5a2c5b6 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -51,12 +51,12 @@ import org.bukkit.event.player.PlayerPickupArrowEvent;
 
 public abstract class AbstractArrow extends Projectile {
 
-    private static final double ARROW_BASE_DAMAGE = 2.0D;
-    private static final EntityDataAccessor<Byte> ID_FLAGS = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
-    private static final EntityDataAccessor<Byte> PIERCE_LEVEL = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
-    private static final int FLAG_CRIT = 1;
-    private static final int FLAG_NOPHYSICS = 2;
-    private static final int FLAG_CROSSBOW = 4;
+    public static final double ARROW_BASE_DAMAGE = 2.0D;
+    public static final EntityDataAccessor<Byte> ID_FLAGS = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> PIERCE_LEVEL = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
+    public static final int FLAG_CRIT = 1;
+    public static final int FLAG_NOPHYSICS = 2;
+    public static final int FLAG_CROSSBOW = 4;
     @Nullable
     private BlockState lastState;
     public boolean inGround;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index f5886a88fd98ede5e85a91eccccb05ac33eb40e2..76fed0502c2b01f7b0cdf6f03ea39570b2c4a4c7 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -56,14 +56,14 @@ public class FishingHook extends Projectile {
     private final RandomSource syncronizedRandom;
     private boolean biting;
     private int outOfWaterTime;
-    private static final int MAX_OUT_OF_WATER_TIME = 10;
+    public static final int MAX_OUT_OF_WATER_TIME = 10;
     public static final EntityDataAccessor<Integer> DATA_HOOKED_ENTITY = SynchedEntityData.defineId(FishingHook.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Boolean> DATA_BITING = SynchedEntityData.defineId(FishingHook.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_BITING = SynchedEntityData.defineId(FishingHook.class, EntityDataSerializers.BOOLEAN);
     private int life;
     private int nibble;
     public int timeUntilLured;
-    private int timeUntilHooked;
-    private float fishAngle;
+    public int timeUntilHooked;
+    public float fishAngle;
     private boolean openWater;
     @Nullable
     public Entity hookedIn;
diff --git a/src/main/java/net/minecraft/world/level/BlockGetter.java b/src/main/java/net/minecraft/world/level/BlockGetter.java
index d1eefa6ef3e9abfe7af4d8310aa64465fa2d5463..fd7bd50a46a48d8540913cd4555661397e64ac36 100644
--- a/src/main/java/net/minecraft/world/level/BlockGetter.java
+++ b/src/main/java/net/minecraft/world/level/BlockGetter.java
@@ -109,6 +109,16 @@ public interface BlockGetter extends LevelHeightAccessor {
         });
     }
 
+    default BlockHitResult clipIgnoreTransparent(ClipContext context) {
+        return (BlockHitResult) traverseBlocksIgnoreTransparent(context.getFrom(), context.getTo(), context, (raytrace1, blockposition) -> {
+            return this.clip(raytrace1, blockposition); // CraftBukkit - moved into separate method
+        }, (raytrace1) -> {
+            Vec3 vec3d = raytrace1.getFrom().subtract(raytrace1.getTo());
+
+            return BlockHitResult.miss(raytrace1.getTo(), Direction.getNearest(vec3d.x, vec3d.y, vec3d.z), new BlockPos(raytrace1.getTo()));
+        });
+    }
+
     @Nullable
     default BlockHitResult clipWithInteractionOverride(Vec3 start, Vec3 end, BlockPos pos, VoxelShape shape, BlockState state) {
         BlockHitResult movingobjectpositionblock = shape.clip(start, end, pos);
@@ -204,4 +214,71 @@ public interface BlockGetter extends LevelHeightAccessor {
             }
         }
     }
+
+    private <T, C> T traverseBlocksIgnoreTransparent(Vec3 start, Vec3 end, C context, BiFunction<C, BlockPos, T> blockHitFactory, Function<C, T> missFactory) {
+        if (start.equals(end)) {
+            return missFactory.apply(context);
+        } else {
+            double d0 = Mth.lerp(-1.0E-7D, end.x, start.x);
+            double d1 = Mth.lerp(-1.0E-7D, end.y, start.y);
+            double d2 = Mth.lerp(-1.0E-7D, end.z, start.z);
+            double d3 = Mth.lerp(-1.0E-7D, start.x, end.x);
+            double d4 = Mth.lerp(-1.0E-7D, start.y, end.y);
+            double d5 = Mth.lerp(-1.0E-7D, start.z, end.z);
+            int i = Mth.floor(d3);
+            int j = Mth.floor(d4);
+            int k = Mth.floor(d5);
+
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(i, j, k);
+            boolean isTransparent = this.getBlockState(blockposition_mutableblockposition.immutable()).isTransparentOnSomeFaces();
+            T t0 = isTransparent ? null : blockHitFactory.apply(context, blockposition_mutableblockposition);
+
+            if (t0 != null) {
+                return t0;
+            } else {
+                double d6 = d0 - d3;
+                double d7 = d1 - d4;
+                double d8 = d2 - d5;
+                int l = Mth.sign(d6);
+                int i1 = Mth.sign(d7);
+                int j1 = Mth.sign(d8);
+                double d9 = l == 0 ? Double.MAX_VALUE : (double) l / d6;
+                double d10 = i1 == 0 ? Double.MAX_VALUE : (double) i1 / d7;
+                double d11 = j1 == 0 ? Double.MAX_VALUE : (double) j1 / d8;
+                double d12 = d9 * (l > 0 ? 1.0D - Mth.frac(d3) : Mth.frac(d3));
+                double d13 = d10 * (i1 > 0 ? 1.0D - Mth.frac(d4) : Mth.frac(d4));
+                double d14 = d11 * (j1 > 0 ? 1.0D - Mth.frac(d5) : Mth.frac(d5));
+
+                T object; // CraftBukkit - decompile error
+
+                do {
+                    if (d12 > 1.0D && d13 > 1.0D && d14 > 1.0D) {
+                        return missFactory.apply(context);
+                    }
+
+                    if (d12 < d13) {
+                        if (d12 < d14) {
+                            i += l;
+                            d12 += d9;
+                        } else {
+                            k += j1;
+                            d14 += d11;
+                        }
+                    } else if (d13 < d14) {
+                        j += i1;
+                        d13 += d10;
+                    } else {
+                        k += j1;
+                        d14 += d11;
+                    }
+
+                    BlockPos.MutableBlockPos mutableBlockPos = blockposition_mutableblockposition.set(i, j, k);
+                    isTransparent = this.getBlockState(mutableBlockPos.immutable()).isTransparentOnSomeFaces();
+                    object = isTransparent ? null : blockHitFactory.apply(context, mutableBlockPos);
+                } while (object == null);
+
+                return object;
+            }
+        }
+    }
 }
