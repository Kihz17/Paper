From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kihz17 <mitchdawdy@gmail.com>
Date: Mon, 25 Apr 2022 10:08:31 -0400
Subject: [PATCH] Add LOS and packet events. Also expose some entity fields.


diff --git a/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb01c0499a4fe8a294105add0f6cff84f8c451c3
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityMovePacketEvent.java
@@ -0,0 +1,71 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class BroadcastEntityMovePacketEvent extends EntityEvent {
+    private final Packet<?> packet;
+    private final PacketType packetType;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public BroadcastEntityMovePacketEvent(@NotNull Entity what, Packet<?> packet) {
+        super(what);
+        this.packet = packet;
+
+        if(packet instanceof ClientboundMoveEntityPacket.Pos) {
+            this.packetType = PacketType.POS;
+        } else if(packet instanceof ClientboundMoveEntityPacket.Rot) {
+            this.packetType = PacketType.ROT;
+        } else if(packet instanceof ClientboundMoveEntityPacket.PosRot) {
+            this.packetType = PacketType.POS_ROT;
+        } else if(packet instanceof ClientboundTeleportEntityPacket) {
+            this.packetType = PacketType.TELEPORT;
+        } else {
+            this.packetType = PacketType.NONE;
+        }
+    }
+
+    public Packet<?> getPacket() {
+        return packet;
+    }
+
+    public ClientboundMoveEntityPacket.Pos getAsPosPacket() {
+        return (ClientboundMoveEntityPacket.Pos) packet;
+    }
+
+    public ClientboundMoveEntityPacket.Rot getAsRotPacket() {
+        return (ClientboundMoveEntityPacket.Rot) packet;
+    }
+
+    public ClientboundMoveEntityPacket.PosRot getAsPosRotPacket() {
+        return (ClientboundMoveEntityPacket.PosRot) packet;
+    }
+
+    public ClientboundTeleportEntityPacket getAsTeleportPacket() {
+        return (ClientboundTeleportEntityPacket) packet;
+    }
+
+    public PacketType getPacketType() {
+        return packetType;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public enum PacketType {
+        NONE,
+        POS,
+        ROT,
+        POS_ROT,
+        TELEPORT
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/BroadcastEntityVelocityPacketEvent.java b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityVelocityPacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..c330d01231d11ffeaad361242d47805ab6e39b60
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/BroadcastEntityVelocityPacketEvent.java
@@ -0,0 +1,27 @@
+package com.destroystokyo.paper.events;
+
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class BroadcastEntityVelocityPacketEvent extends EntityEvent {
+    private Vec3 velocity;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public BroadcastEntityVelocityPacketEvent(@NotNull Entity what, Vec3 vel) {
+        super(what);
+        this.velocity = vel;
+    }
+
+    public Vec3 getVelocity() {
+        return velocity;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java b/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..9ccd2bb2c717fa9da9aa9324c0cadb3291076559
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/events/PlayerUpdateEntityLineOfSightEvent.java
@@ -0,0 +1,34 @@
+package com.destroystokyo.paper.events;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+import org.bukkit.event.player.PlayerEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerUpdateEntityLineOfSightEvent extends PlayerEvent {
+    private final Entity entityInLOS;
+    private final boolean isInLOS;
+
+    private static final HandlerList handlers = new HandlerList();
+
+    public PlayerUpdateEntityLineOfSightEvent(@NotNull Player player, @NotNull Entity entity, boolean isInLOS) {
+        super(player);
+        this.entityInLOS = entity;
+        this.isInLOS = isInLOS;
+    }
+
+    public Entity getEntity() {
+        return entityInLOS;
+    }
+
+    public boolean isInLOS() {
+        return isInLOS;
+    }
+
+    @Override
+    public @NotNull HandlerList getHandlers() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index f91e1a876ad4c46a7c92cead18947a941b4d9e68..68c3c07a0a858c0e5464297d4ed76038d47d3513 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -1,5 +1,7 @@
 package net.minecraft.server.level;
 
+import com.destroystokyo.paper.events.BroadcastEntityMovePacketEvent;
+import com.destroystokyo.paper.events.BroadcastEntityVelocityPacketEvent;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
@@ -34,7 +36,10 @@ import net.minecraft.world.entity.decoration.ItemFrame;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.MapItem;
+import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
@@ -69,6 +74,12 @@ public class ServerEntity {
     // CraftBukkit start
     final Set<ServerPlayerConnection> trackedPlayers; // Paper - private -> package
 
+    public static int losCheckInterval = 20;
+    public static double losYThreshold = 15;
+    public static double losHorizontalThreshold = 20;
+
+    private static final double[] raycastVerticalOffsets = new double[] { 0.0, -0.5, -1.0};
+
     public ServerEntity(ServerLevel worldserver, Entity entity, int i, boolean flag, Consumer<Packet<?>> consumer, Set<ServerPlayerConnection> trackedPlayers) {
         this.trackedPlayers = trackedPlayers;
         // CraftBukkit end
@@ -121,6 +132,19 @@ public class ServerEntity {
             this.sendDirtyEntityData();
         }
 
+        // Check if each tracked entity can view this server entity
+        if(this.tickCount % losCheckInterval == 0) {
+            for(ServerPlayerConnection playerConn : trackedPlayers) {
+                ServerPlayer player = playerConn.getPlayer();
+
+                if(hasLOS(player)) { // We have LOS
+                    player.addEntityInLOS(this.entity.getUUID());
+                } else { // Not in LOS
+                    player.removeEntityInLOS(this.entity.getUUID());
+                }
+            }
+        }
+
         if (this.tickCount % this.updateInterval == 0 || this.entity.hasImpulse || this.entity.getEntityData().isDirty()) {
             int i;
             int j;
@@ -197,11 +221,13 @@ public class ServerEntity {
                     if (d0 > 1.0E-7D || d0 > 0.0D && vec3d1.lengthSqr() == 0.0D) {
                         this.ap = vec3d1;
                         this.broadcast.accept(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.ap));
+                        this.entity.level.getCraftServer().getPluginManager().callEvent(new BroadcastEntityVelocityPacketEvent(this.entity.getBukkitEntity(), this.ap));
                     }
                 }
 
                 if (packet1 != null) {
                     this.broadcast.accept(packet1);
+                    this.entity.level.getCraftServer().getPluginManager().callEvent(new BroadcastEntityMovePacketEvent(this.entity.getBukkitEntity(), packet1));
                 }
 
                 this.sendDirtyEntityData();
@@ -258,6 +284,7 @@ public class ServerEntity {
 
     public void removePairing(ServerPlayer player) {
         this.entity.stopSeenByPlayer(player);
+        player.removeEntityInLOS(this.entity.getUUID());
         player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
     }
 
@@ -414,4 +441,42 @@ public class ServerEntity {
         }
 
     }
+
+    private boolean hasLOS(ServerPlayer player) {
+        // Get distance from the player to this entity
+        double x = player.getX() - this.entity.getX();
+        double y = player.getY() - this.entity.getY();
+        double z = player.getZ() - this.entity.getZ();
+        double yDistance = Math.sqrt(y * y);
+        double horizontalDistance = Math.sqrt((x * x) + (z * z));
+
+        if(yDistance <= losYThreshold && horizontalDistance <= losHorizontalThreshold) // We are close enough to them, just return true
+            return true;
+
+        Vec3 originalPosition = player.getEyePosition();
+        Vec3 originalEntityPos = this.entity.getEyePosition();
+
+        for(int i = 1; i <= 3; i++) {
+            float originYOffset = player.getEyeHeight() - (player.getEyeHeight() / (float)i);
+            float endYOffset = this.entity.getEyeHeight() - (this.entity.getEyeHeight() / (float) i);
+
+            Vec3 start = new Vec3(originalPosition.x, originalPosition.y - originYOffset, originalPosition.z);
+            Vec3 end = new Vec3(originalEntityPos.x, originalEntityPos.y - endYOffset, originalEntityPos.z);
+
+            Vec3 left = end.subtract(start).normalize().cross(new Vec3(0.0f, 1.0, 0.0));
+            for(int j = -1; j <= 1; j++) {
+                Vec3 offset = left.scale(j);
+                Vec3 rayOrigin = start.add(offset);
+                Vec3 rayEnd = end.add(offset);
+
+                ClipContext ray = new ClipContext(rayOrigin, rayEnd, ClipContext.Block.OUTLINE, ClipContext.Fluid.NONE, player);
+                BlockHitResult hitResult = player.level.clipIgnoreTransparent(ray);
+
+                if(hitResult.getType() != HitResult.Type.BLOCK) // We didn't hit a block, we have LOS, stop checking
+                    return true;
+            }
+        }
+
+        return false; // All of our rays hit a block, we can't see this person
+    }
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 22452aa7eefa350c3b0d0d19a23c76c8ec811de3..71acbad9cf6764f95daa2007de42d16c5406b29a 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1,19 +1,14 @@
 package net.minecraft.server.level;
 
 import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
+import com.destroystokyo.paper.events.PlayerUpdateEntityLineOfSightEvent;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.Random;
-import java.util.UUID;
+
+import java.util.*;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -258,6 +253,9 @@ public class ServerPlayer extends Player {
     public final com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleHashSet; // Paper
     public org.bukkit.event.player.PlayerQuitEvent.QuitReason quitReason = null; // Paper - there are a lot of changes to do if we change all methods leading to the event
 
+    public final Set<UUID> visibleEntities = new HashSet<>();
+    public final Set<UUID> ignoreLoSChecks = new HashSet<>();
+
     public ServerPlayer(MinecraftServer server, ServerLevel world, GameProfile profile) {
         super(world, world.getSharedSpawnPos(), world.getSharedSpawnAngle(), profile);
         this.chatVisibility = ChatVisiblity.FULL;
@@ -330,6 +328,25 @@ public class ServerPlayer extends Player {
         this.maxHealthCache = this.getMaxHealth();
         this.cachedSingleMobDistanceMap = new com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<>(this); // Paper
     }
+
+    public void addEntityInLOS(UUID uuid) {
+        if(!visibleEntities.contains(uuid)) {
+            org.bukkit.entity.Entity craftEntity = this.level.getCraftServer().getEntity(uuid);
+            if(craftEntity != null) {
+                visibleEntities.add(uuid);
+                this.level.getCraftServer().getPluginManager().callEvent(new PlayerUpdateEntityLineOfSightEvent(getBukkitEntity(), craftEntity, true));
+            }
+        }
+    }
+
+    public void removeEntityInLOS(UUID uuid) {
+        if(visibleEntities.remove(uuid)) {
+            org.bukkit.entity.Entity craftEntity = this.level.getCraftServer().getEntity(uuid);
+            if(craftEntity != null)
+                this.level.getCraftServer().getPluginManager().callEvent(new PlayerUpdateEntityLineOfSightEvent(getBukkitEntity(), craftEntity, false));
+        }
+    }
+
     // Paper start - Chunk priority
     public BlockPos getPointInFront(double inFront) {
         double rads = Math.toRadians(net.minecraft.server.MCUtil.normalizeYaw(this.yRot + 90)); // MC rotates yaw 90 for some odd reason
diff --git a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
index 058fb3696c7ece4a7b6971886b1760b26add733b..b47303b9803ef9f6dc637c5b7c76af270fec541d 100644
--- a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
+++ b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
@@ -60,9 +60,9 @@ public class ServerConnectionListener {
     final MinecraftServer server;
     public volatile boolean running;
     private final List<ChannelFuture> channels = Collections.synchronizedList(Lists.newArrayList());
-    final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
+    public final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
     // Paper start - prevent blocking on adding a new network manager while the server is ticking
-    private final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    public final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
     private static final boolean disableFlushConsolidation = Boolean.getBoolean("Paper.disableFlushConsolidate"); // Paper
     private final void addPending() {
         Connection manager = null;
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 49cf3601df7b145d49b1fe9a71ba0bc60c5394b3..b6e5dc18e4bba1ed615186008735bff0638ad5a1 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -9,17 +9,8 @@ import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
+
+import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
@@ -49,6 +40,7 @@ import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
@@ -270,7 +262,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public int invulnerableTime;
     protected boolean firstTick;
     protected final SynchedEntityData entityData;
-    protected static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
     protected static final int FLAG_ONFIRE = 0;
     private static final int FLAG_SHIFT_KEY_DOWN = 1;
     private static final int FLAG_SPRINTING = 3;
@@ -278,13 +270,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     private static final int FLAG_INVISIBLE = 5;
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
-    private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
-    private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    protected static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
-    private static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
+    public static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
+    public static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private EntityInLevelCallback levelCallback;
     private Vec3 packetCoordinates;
     public boolean noCulling;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 1521f53ee1bd85ca44a68b2c9d969eaf63fa342e..950408bf27755a49b89313ef5a8e7536214dc3f1 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -168,13 +168,13 @@ public abstract class LivingEntity extends Entity {
     protected static final int LIVING_ENTITY_FLAG_IS_USING = 1;
     protected static final int LIVING_ENTITY_FLAG_OFF_HAND = 2;
     protected static final int LIVING_ENTITY_FLAG_SPIN_ATTACK = 4;
-    protected static final EntityDataAccessor<Byte> DATA_LIVING_ENTITY_FLAGS = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> DATA_LIVING_ENTITY_FLAGS = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BYTE);
     public static final EntityDataAccessor<Float> DATA_HEALTH_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.FLOAT);
-    private static final EntityDataAccessor<Integer> DATA_EFFECT_COLOR_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Boolean> DATA_EFFECT_AMBIENCE_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Integer> DATA_EFFECT_COLOR_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Boolean> DATA_EFFECT_AMBIENCE_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.BOOLEAN);
     public static final EntityDataAccessor<Integer> DATA_ARROW_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Integer> DATA_STINGER_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Optional<BlockPos>> SLEEPING_POS_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.OPTIONAL_BLOCK_POS);
+    public static final EntityDataAccessor<Integer> DATA_STINGER_COUNT_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Optional<BlockPos>> SLEEPING_POS_ID = SynchedEntityData.defineId(LivingEntity.class, EntityDataSerializers.OPTIONAL_BLOCK_POS);
     protected static final float DEFAULT_EYE_HEIGHT = 1.74F;
     protected static final EntityDimensions SLEEPING_DIMENSIONS = EntityDimensions.fixed(0.2F, 0.2F);
     public static final float EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT = 0.5F;
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index b1ae9b0d8b229e2a6797a173cb11ecc0f43e2592..38373f86554a9c6feef3fc35409c584d4f0615f6 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -85,7 +85,7 @@ import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
 
 public abstract class Mob extends LivingEntity {
 
-    private static final EntityDataAccessor<Byte> DATA_MOB_FLAGS_ID = SynchedEntityData.defineId(Mob.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> DATA_MOB_FLAGS_ID = SynchedEntityData.defineId(Mob.class, EntityDataSerializers.BYTE);
     private static final int MOB_FLAG_NO_AI = 1;
     private static final int MOB_FLAG_LEFTHANDED = 2;
     private static final int MOB_FLAG_AGGRESSIVE = 4;
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 2483d7df7f1bf94344afd38b37602c645a4a2dff..f6e1891384680af5e7bfe4564936355cf1f8196e 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -141,12 +141,12 @@ public abstract class Player extends LivingEntity {
     // CraftBukkit - decompile error
     private static final Map<Pose, EntityDimensions> POSES = ImmutableMap.<Pose, EntityDimensions>builder().put(Pose.STANDING, Player.STANDING_DIMENSIONS).put(Pose.SLEEPING, Player.SLEEPING_DIMENSIONS).put(Pose.FALL_FLYING, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.SWIMMING, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.SPIN_ATTACK, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.CROUCHING, EntityDimensions.scalable(0.6F, 1.5F)).put(Pose.DYING, EntityDimensions.fixed(0.2F, 0.2F)).build();
     private static final int FLY_ACHIEVEMENT_SPEED = 25;
-    private static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
-    private static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
+    public static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
     public static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
-    protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
+    public static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
+    public static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     private long timeEntitySatOnShoulder;
     private final Inventory inventory = new Inventory(this);
     protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer(this); // CraftBukkit - add "this" to constructor
diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
index 53d0024daf6963ac4dab575666b0d6a74a39a958..132469aa429952af67b6d0414c6424259e7509a1 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -51,8 +51,8 @@ import org.bukkit.event.player.PlayerPickupArrowEvent;
 public abstract class AbstractArrow extends Projectile {
 
     private static final double ARROW_BASE_DAMAGE = 2.0D;
-    private static final EntityDataAccessor<Byte> ID_FLAGS = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
-    private static final EntityDataAccessor<Byte> PIERCE_LEVEL = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> ID_FLAGS = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> PIERCE_LEVEL = SynchedEntityData.defineId(AbstractArrow.class, EntityDataSerializers.BYTE);
     private static final int FLAG_CRIT = 1;
     private static final int FLAG_NOPHYSICS = 2;
     private static final int FLAG_CROSSBOW = 4;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index 3789a0db398766f0fbc9e5ac5bf4228a0a0dac88..e22d65ecd4ce19fc4c1fdfab22610ec464a36d7e 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -62,8 +62,8 @@ public class FishingHook extends Projectile {
     private int life;
     private int nibble;
     public int timeUntilLured;
-    private int timeUntilHooked;
-    private float fishAngle;
+    public int timeUntilHooked;
+    public float fishAngle;
     private boolean openWater;
     @Nullable
     public Entity hookedIn;
diff --git a/src/main/java/net/minecraft/world/level/BlockGetter.java b/src/main/java/net/minecraft/world/level/BlockGetter.java
index d1eefa6ef3e9abfe7af4d8310aa64465fa2d5463..fd7bd50a46a48d8540913cd4555661397e64ac36 100644
--- a/src/main/java/net/minecraft/world/level/BlockGetter.java
+++ b/src/main/java/net/minecraft/world/level/BlockGetter.java
@@ -109,6 +109,16 @@ public interface BlockGetter extends LevelHeightAccessor {
         });
     }
 
+    default BlockHitResult clipIgnoreTransparent(ClipContext context) {
+        return (BlockHitResult) traverseBlocksIgnoreTransparent(context.getFrom(), context.getTo(), context, (raytrace1, blockposition) -> {
+            return this.clip(raytrace1, blockposition); // CraftBukkit - moved into separate method
+        }, (raytrace1) -> {
+            Vec3 vec3d = raytrace1.getFrom().subtract(raytrace1.getTo());
+
+            return BlockHitResult.miss(raytrace1.getTo(), Direction.getNearest(vec3d.x, vec3d.y, vec3d.z), new BlockPos(raytrace1.getTo()));
+        });
+    }
+
     @Nullable
     default BlockHitResult clipWithInteractionOverride(Vec3 start, Vec3 end, BlockPos pos, VoxelShape shape, BlockState state) {
         BlockHitResult movingobjectpositionblock = shape.clip(start, end, pos);
@@ -204,4 +214,71 @@ public interface BlockGetter extends LevelHeightAccessor {
             }
         }
     }
+
+    private <T, C> T traverseBlocksIgnoreTransparent(Vec3 start, Vec3 end, C context, BiFunction<C, BlockPos, T> blockHitFactory, Function<C, T> missFactory) {
+        if (start.equals(end)) {
+            return missFactory.apply(context);
+        } else {
+            double d0 = Mth.lerp(-1.0E-7D, end.x, start.x);
+            double d1 = Mth.lerp(-1.0E-7D, end.y, start.y);
+            double d2 = Mth.lerp(-1.0E-7D, end.z, start.z);
+            double d3 = Mth.lerp(-1.0E-7D, start.x, end.x);
+            double d4 = Mth.lerp(-1.0E-7D, start.y, end.y);
+            double d5 = Mth.lerp(-1.0E-7D, start.z, end.z);
+            int i = Mth.floor(d3);
+            int j = Mth.floor(d4);
+            int k = Mth.floor(d5);
+
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(i, j, k);
+            boolean isTransparent = this.getBlockState(blockposition_mutableblockposition.immutable()).isTransparentOnSomeFaces();
+            T t0 = isTransparent ? null : blockHitFactory.apply(context, blockposition_mutableblockposition);
+
+            if (t0 != null) {
+                return t0;
+            } else {
+                double d6 = d0 - d3;
+                double d7 = d1 - d4;
+                double d8 = d2 - d5;
+                int l = Mth.sign(d6);
+                int i1 = Mth.sign(d7);
+                int j1 = Mth.sign(d8);
+                double d9 = l == 0 ? Double.MAX_VALUE : (double) l / d6;
+                double d10 = i1 == 0 ? Double.MAX_VALUE : (double) i1 / d7;
+                double d11 = j1 == 0 ? Double.MAX_VALUE : (double) j1 / d8;
+                double d12 = d9 * (l > 0 ? 1.0D - Mth.frac(d3) : Mth.frac(d3));
+                double d13 = d10 * (i1 > 0 ? 1.0D - Mth.frac(d4) : Mth.frac(d4));
+                double d14 = d11 * (j1 > 0 ? 1.0D - Mth.frac(d5) : Mth.frac(d5));
+
+                T object; // CraftBukkit - decompile error
+
+                do {
+                    if (d12 > 1.0D && d13 > 1.0D && d14 > 1.0D) {
+                        return missFactory.apply(context);
+                    }
+
+                    if (d12 < d13) {
+                        if (d12 < d14) {
+                            i += l;
+                            d12 += d9;
+                        } else {
+                            k += j1;
+                            d14 += d11;
+                        }
+                    } else if (d13 < d14) {
+                        j += i1;
+                        d13 += d10;
+                    } else {
+                        k += j1;
+                        d14 += d11;
+                    }
+
+                    BlockPos.MutableBlockPos mutableBlockPos = blockposition_mutableblockposition.set(i, j, k);
+                    isTransparent = this.getBlockState(mutableBlockPos.immutable()).isTransparentOnSomeFaces();
+                    object = isTransparent ? null : blockHitFactory.apply(context, mutableBlockPos);
+                } while (object == null);
+
+                return object;
+            }
+        }
+    }
 }
