From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kihz17 <mitchdawdy@gmail.com>
Date: Sat, 4 Jun 2022 16:03:51 -0400
Subject: [PATCH] Expose fields in PlayerList.


diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 7d4e2d2241bb34b7898b71d64f6c9067801ee941..20eb77eaabaf9a1f413c82c2fe5188ce4f8a42fe 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -126,34 +126,34 @@ public abstract class PlayerList {
     public static final File IPBANLIST_FILE = new File("banned-ips.json");
     public static final File OPLIST_FILE = new File("ops.json");
     public static final File WHITELIST_FILE = new File("whitelist.json");
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final int SEND_PLAYER_INFO_INTERVAL = 600;
-    private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
-    private final MinecraftServer server;
+    public static final Logger LOGGER = LogUtils.getLogger();
+    public static final int SEND_PLAYER_INFO_INTERVAL = 600;
+    public static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
+    public final MinecraftServer server;
     public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
-    private final UserBanList bans;
-    private final IpBanList ipBans;
-    private final ServerOpList ops;
-    private final UserWhiteList whitelist;
-    private final Map<UUID, ServerPlayer> pendingPlayers = Maps.newHashMap(); // Paper
+    public final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
+    public final UserBanList bans;
+    public final IpBanList ipBans;
+    public final ServerOpList ops;
+    public final UserWhiteList whitelist;
+    public final Map<UUID, ServerPlayer> pendingPlayers = Maps.newHashMap(); // Paper
     // CraftBukkit start
     // private final Map<UUID, ServerStatisticManager> stats;
     // private final Map<UUID, AdvancementDataPlayer> advancements;
     // CraftBukkit end
     public final PlayerDataStorage playerIo;
-    private boolean doWhiteList;
-    private final RegistryAccess.Frozen registryHolder;
+    public boolean doWhiteList;
+    public final RegistryAccess.Frozen registryHolder;
     protected int maxPlayers; public final void setMaxPlayers(int maxPlayers) { this.maxPlayers = maxPlayers; } // Paper - remove final and add setter
-    private int viewDistance;
-    private int simulationDistance;
-    private boolean allowCheatsForAllPlayers;
-    private static final boolean ALLOW_LOGOUTIVATOR = false;
-    private int sendAllPlayerInfoIn;
+    public int viewDistance;
+    public int simulationDistance;
+    public boolean allowCheatsForAllPlayers;
+    public static final boolean ALLOW_LOGOUTIVATOR = false;
+    public int sendAllPlayerInfoIn;
 
     // CraftBukkit start
-    private CraftServer cserver;
-    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
+    public CraftServer cserver;
+    public final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
     public @Nullable String collideRuleTeamName; // Paper - Team name used for collideRule
 
     public PlayerList(MinecraftServer server, RegistryAccess.Frozen registryManager, PlayerDataStorage saveHandler, int maxPlayers) {
@@ -294,17 +294,13 @@ public abstract class PlayerList {
         distanceManager.addTicket(net.minecraft.server.level.TicketType.LOGIN, pos, 31, pos.toLong());
         worldserver1.getChunkSource().markAreaHighPriority(pos, 28, 3); // Paper - Chunk priority
         worldserver1.getChunkSource().getChunkAtAsynchronously(chunkX, chunkZ, true, false).thenApply(chunk -> { // Paper - Chunk priority
-            LOGGER.info("First and then");
             net.minecraft.server.level.ChunkHolder updatingChunk = playerChunkMap.getUpdatingChunkIfPresent(pos.toLong());
             if (updatingChunk != null) {
-                LOGGER.info("Chunk not null");
                 return updatingChunk.getEntityTickingChunkFuture();
             } else {
-                LOGGER.info("Was null");
                 return java.util.concurrent.CompletableFuture.completedFuture(chunk);
             }
         }).thenAccept(chunk -> {
-            LOGGER.info("Final step");
             playerconnection.playerJoinReady = () -> {
                 postChunkLoadJoin(
                     player, finalWorldserver, connection, playerconnection,
@@ -319,7 +315,7 @@ public abstract class PlayerList {
         return player != null ? player : pendingPlayers.get(uuid);
     }
 
-    void disconnectPendingPlayer(ServerPlayer entityplayer) {
+    public void disconnectPendingPlayer(ServerPlayer entityplayer) {
         TranslatableComponent msg = new TranslatableComponent("multiplayer.disconnect.duplicate_login", new Object[0]);
         entityplayer.networkManager.send(new ClientboundDisconnectPacket(msg), (future) -> {
             entityplayer.networkManager.disconnect(msg);
@@ -327,11 +323,9 @@ public abstract class PlayerList {
         });
     }
 
-    private void postChunkLoadJoin(ServerPlayer player, ServerLevel worldserver1, Connection networkmanager, ServerGamePacketListenerImpl playerconnection, CompoundTag nbttagcompound, String s1, String s) {
-        LOGGER.info("Post chunk load for player " + player.getName());
+    public void postChunkLoadJoin(ServerPlayer player, ServerLevel worldserver1, Connection networkmanager, ServerGamePacketListenerImpl playerconnection, CompoundTag nbttagcompound, String s1, String s) {
         pendingPlayers.remove(player.getUUID(), player);
         if (!networkmanager.isConnected()) {
-            LOGGER.info("Not connected");
             return;
         }
         player.didPlayerJoinEvent = true;
@@ -347,7 +341,6 @@ public abstract class PlayerList {
         chatmessage.withStyle(ChatFormatting.YELLOW);
         Component joinMessage = chatmessage; // Paper - Adventure
 
-        LOGGER.info("We passed so far");
         playerconnection.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
         this.players.add(player);
         this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
@@ -366,7 +359,6 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
-        LOGGER.info("B4 join event");
         PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, PaperAdventure.asAdventure(chatmessage)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
@@ -438,7 +430,8 @@ public abstract class PlayerList {
             worldserver1.getLightEngine(), null, null, true, false)
         );
     }
-    private void mountSavedVehicle(ServerPlayer player, ServerLevel worldserver1, CompoundTag nbttagcompound) {
+
+    public void mountSavedVehicle(ServerPlayer player, ServerLevel worldserver1, CompoundTag nbttagcompound) {
         // Paper end
         if (nbttagcompound != null && nbttagcompound.contains("RootVehicle", 10)) {
             CompoundTag nbttagcompound1 = nbttagcompound.getCompound("RootVehicle");
@@ -1159,7 +1152,7 @@ public abstract class PlayerList {
 
     }
 
-    private void sendPlayerPermissionLevel(ServerPlayer player, int permissionLevel) {
+    public void sendPlayerPermissionLevel(ServerPlayer player, int permissionLevel) {
         // Paper start - add recalculatePermissions parameter
         this.sendPlayerPermissionLevel(player, permissionLevel, true);
     }
