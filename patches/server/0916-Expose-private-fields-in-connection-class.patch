From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kihz17 <mitchdawdy@gmail.com>
Date: Wed, 15 Jun 2022 19:00:27 -0400
Subject: [PATCH] Expose private fields in connection class.


diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 9bbf990212ee55a267d0eb1e863618c50fa706da..cd47eea88d6eaedf839a20855358fc81d7b794d8 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -55,8 +55,8 @@ import org.slf4j.MarkerFactory;
 import io.netty.util.concurrent.AbstractEventExecutor; // Paper
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
-    private static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
-    private static final Logger LOGGER = LogUtils.getLogger();
+    public static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
+    public static final Logger LOGGER = LogUtils.getLogger();
     public static final Marker ROOT_MARKER = MarkerFactory.getMarker("NETWORK");
     public static final Marker PACKET_MARKER = (Marker) Util.make(MarkerFactory.getMarker("NETWORK_PACKETS"), (marker) -> {
         marker.add(Connection.ROOT_MARKER);
@@ -77,8 +77,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     public static final LazyLoadedValue<DefaultEventLoopGroup> LOCAL_WORKER_GROUP = new LazyLoadedValue<>(() -> {
         return new DefaultEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Client IO #%d").setDaemon(true).setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(LOGGER)).build()); // Paper
     });
-    private final PacketFlow receiving;
-    private final Queue<Connection.PacketHolder> queue = Queues.newConcurrentLinkedQueue();
+    public final PacketFlow receiving;
+    public final Queue<Connection.PacketHolder> queue = Queues.newConcurrentLinkedQueue();
     public Channel channel;
     public SocketAddress address;
     // Spigot Start
@@ -86,27 +86,27 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     public com.mojang.authlib.properties.Property[] spoofedProfile;
     public boolean preparing = true;
     // Spigot End
-    private PacketListener packetListener;
-    private Component disconnectedReason;
-    private boolean encrypted;
-    private boolean disconnectionHandled;
-    private int receivedPackets;
-    private int sentPackets;
-    private float averageReceivedPackets;
-    private float averageSentPackets;
-    private int tickCount;
-    private boolean handlingFault;
+    public PacketListener packetListener;
+    public Component disconnectedReason;
+    public boolean encrypted;
+    public boolean disconnectionHandled;
+    public int receivedPackets;
+    public int sentPackets;
+    public float averageReceivedPackets;
+    public float averageSentPackets;
+    public int tickCount;
+    public boolean handlingFault;
     // Paper start - NetworkClient implementation
     public int protocolVersion;
     public java.net.InetSocketAddress virtualHost;
-    private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
+    public static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
     // Optimize network
     public boolean isPending = true;
     public boolean queueImmunity = false;
     public ConnectionProtocol protocol;
     // Paper end
     // Paper start - add pending task queue
-    private final Queue<Runnable> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    public final Queue<Runnable> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
     public void execute(final Runnable run) {
         if (this.channel == null || !this.channel.isRegistered()) {
             run.run();
@@ -130,9 +130,9 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     // Paper start - allow controlled flushing
     volatile boolean canFlush = true;
-    private final java.util.concurrent.atomic.AtomicInteger packetWrites = new java.util.concurrent.atomic.AtomicInteger();
-    private int flushPacketsStart;
-    private final Object flushLock = new Object();
+    public final java.util.concurrent.atomic.AtomicInteger packetWrites = new java.util.concurrent.atomic.AtomicInteger();
+    public int flushPacketsStart;
+    public final Object flushLock = new Object();
 
     public void disableAutomaticFlush() {
         synchronized (this.flushLock) {
@@ -150,7 +150,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
     }
 
-    private final void flush() {
+    public final void flush() {
         if (this.channel.eventLoop().inEventLoop()) {
             this.channel.flush();
         } else {
@@ -167,8 +167,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     ) : null;
     protected final java.util.Map<Class<? extends net.minecraft.network.protocol.Packet<?>>, io.papermc.paper.util.IntervalledCounter> packetSpecificLimits = new java.util.HashMap<>();
 
-    private boolean stopReadingPackets;
-    private void killForPacketSpam() {
+    public boolean stopReadingPackets;
+    public void killForPacketSpam() {
         this.sendPacket(new ClientboundDisconnectPacket(org.bukkit.craftbukkit.util.CraftChatMessage.fromString(com.destroystokyo.paper.PaperConfig.kickMessage, true)[0]), (future) -> {
             this.disconnect(org.bukkit.craftbukkit.util.CraftChatMessage.fromString(com.destroystokyo.paper.PaperConfig.kickMessage, true)[0]);
         });
@@ -311,7 +311,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     }
 
-    private static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
+    public static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
         packet.handle((T) listener); // CraftBukkit - decompile error
     }
 
@@ -327,8 +327,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return null;
         }
     }
-    private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
-        private static java.util.List<Packet> buildExtraPackets(Packet packet) {
+    public static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
+        public static java.util.List<Packet> buildExtraPackets(Packet packet) {
             java.util.List<Packet> extra = packet.getExtraPackets();
             if (extra == null || extra.isEmpty()) {
                 return null;
@@ -338,7 +338,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return ret;
         }
 
-        private static void buildExtraPackets0(java.util.List<Packet> extraPackets, java.util.List<Packet> into) {
+        public static void buildExtraPackets0(java.util.List<Packet> extraPackets, java.util.List<Packet> into) {
             for (Packet extra : extraPackets) {
                 into.add(extra);
                 java.util.List<Packet> extraExtra = extra.getExtraPackets();
@@ -348,7 +348,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             }
         }
         // Paper start
-        private static boolean canSendImmediate(Connection networkManager, Packet<?> packet) {
+        public static boolean canSendImmediate(Connection networkManager, Packet<?> packet) {
             return networkManager.isPending || networkManager.protocol != ConnectionProtocol.PLAY ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundKeepAlivePacket ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundChatPacket ||
@@ -402,11 +402,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         // Paper end
     }
 
-    private void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
+    public void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
         // Paper start - add flush parameter
         this.writePacket(packet, callback, Boolean.TRUE);
     }
-    private void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, Boolean flushConditional) {
+    public void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, Boolean flushConditional) {
         this.packetWrites.getAndIncrement(); // must be befeore using canFlush
         boolean effectiveFlush = flushConditional == null ? this.canFlush : flushConditional.booleanValue();
         final boolean flush = effectiveFlush || packet instanceof net.minecraft.network.protocol.game.ClientboundKeepAlivePacket || packet instanceof ClientboundDisconnectPacket; // no delay for certain packets
@@ -440,11 +440,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     }
 
-    private void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState) {
+    public void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState) {
         // Paper start - add flush parameter
         this.doSendPacket(packet, callback, packetState, currentState, true);
     }
-    private void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState, boolean flush) {
+    public void doSendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, ConnectionProtocol packetState, ConnectionProtocol currentState, boolean flush) {
         // Paper end - add flush parameter
         if (packetState != currentState) {
             this.setProtocol(packetState);
@@ -480,12 +480,12 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         // Paper end
     }
 
-    private ConnectionProtocol getCurrentProtocol() {
+    public ConnectionProtocol getCurrentProtocol() {
         return (ConnectionProtocol) this.channel.attr(Connection.ATTRIBUTE_PROTOCOL).get();
     }
 
     // Paper start - rewrite this to be safer if ran off main thread
-    private boolean flushQueue() { // void -> boolean
+    public boolean flushQueue() { // void -> boolean
         if (!isConnected()) {
             return true;
         }
@@ -499,7 +499,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
         return false;
     }
-    private boolean processQueue() {
+    public boolean processQueue() {
         try { // Paper - add pending task queue
         if (this.queue.isEmpty()) return true;
         // Paper start - make only one flush call per sendPacketQueue() call
@@ -541,9 +541,9 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
     // Paper end
 
-    private static final int MAX_PER_TICK = com.destroystokyo.paper.PaperConfig.maxJoinsPerTick; // Paper
-    private static int joinAttemptsThisTick; // Paper
-    private static int currTick; // Paper
+    public static final int MAX_PER_TICK = com.destroystokyo.paper.PaperConfig.maxJoinsPerTick; // Paper
+    public static int joinAttemptsThisTick; // Paper
+    public static int currTick; // Paper
     public void tick() {
         this.flushQueue();
         // Paper start
@@ -788,7 +788,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         return this.averageSentPackets;
     }
 
-    private static class PacketHolder {
+    public static class PacketHolder {
 
         final Packet<?> packet;
         @Nullable
